// Code generated by github.com/aoldershaw/interpolate. Do not edit.
package atc

import (
	"encoding/json"

	"github.com/aoldershaw/interpolate"
)

type InterpPlan struct {
	ID             PlanID                 `json:"id"`
	Attempts       []int                  `json:"attempts,omitempty"`
	Get            *InterpGetPlan         `json:"get,omitempty"`
	Put            *InterpPutPlan         `json:"put,omitempty"`
	Check          *InterpCheckPlan       `json:"check,omitempty"`
	Task           *InterpTaskPlan        `json:"task,omitempty"`
	SetPipeline    *InterpSetPipelinePlan `json:"set_pipeline,omitempty"`
	LoadVar        *InterpLoadVarPlan     `json:"load_var,omitempty"`
	Do             *InterpDoPlan          `json:"do,omitempty"`
	InParallel     *InterpInParallelPlan  `json:"in_parallel,omitempty"`
	Aggregate      *InterpAggregatePlan   `json:"aggregate,omitempty"`
	Across         *InterpAcrossPlan      `json:"across,omitempty"`
	OnSuccess      *InterpOnSuccessPlan   `json:"on_success,omitempty"`
	OnFailure      *InterpOnFailurePlan   `json:"on_failure,omitempty"`
	OnAbort        *InterpOnAbortPlan     `json:"on_abort,omitempty"`
	OnError        *InterpOnErrorPlan     `json:"on_error,omitempty"`
	Ensure         *InterpEnsurePlan      `json:"ensure,omitempty"`
	Try            *InterpTryPlan         `json:"try,omitempty"`
	Timeout        *InterpTimeoutPlan     `json:"timeout,omitempty"`
	Retry          *InterpRetryPlan       `json:"retry,omitempty"`
	ArtifactInput  *ArtifactInputPlan     `json:"artifact_input,omitempty"`
	ArtifactOutput *ArtifactOutputPlan    `json:"artifact_output,omitempty"`
	DependentGet   *DependentGetPlan      `json:"dependent_get,omitempty"`
}

func (i InterpPlan) Interpolate(resolver interpolate.Resolver) (Plan, error) {
	target := Plan{
		ID:             i.ID,
		Attempts:       i.Attempts,
		ArtifactInput:  i.ArtifactInput,
		ArtifactOutput: i.ArtifactOutput,
		DependentGet:   i.DependentGet,
	}
	var err error
	_ = err

	if i.Get != nil {
		v, err := i.Get.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.Get = &v
	}

	if i.Put != nil {
		v, err := i.Put.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.Put = &v
	}

	if i.Check != nil {
		v, err := i.Check.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.Check = &v
	}

	if i.Task != nil {
		v, err := i.Task.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.Task = &v
	}

	if i.SetPipeline != nil {
		v, err := i.SetPipeline.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.SetPipeline = &v
	}

	if i.LoadVar != nil {
		v, err := i.LoadVar.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.LoadVar = &v
	}

	if i.Do != nil {
		v, err := i.Do.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.Do = &v
	}

	if i.InParallel != nil {
		v, err := i.InParallel.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.InParallel = &v
	}

	if i.Aggregate != nil {
		v, err := i.Aggregate.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.Aggregate = &v
	}

	if i.Across != nil {
		v, err := i.Across.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.Across = &v
	}

	if i.OnSuccess != nil {
		v, err := i.OnSuccess.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.OnSuccess = &v
	}

	if i.OnFailure != nil {
		v, err := i.OnFailure.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.OnFailure = &v
	}

	if i.OnAbort != nil {
		v, err := i.OnAbort.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.OnAbort = &v
	}

	if i.OnError != nil {
		v, err := i.OnError.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.OnError = &v
	}

	if i.Ensure != nil {
		v, err := i.Ensure.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.Ensure = &v
	}

	if i.Try != nil {
		v, err := i.Try.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.Try = &v
	}

	if i.Timeout != nil {
		v, err := i.Timeout.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.Timeout = &v
	}

	if i.Retry != nil {
		v, err := i.Retry.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.Retry = &v
	}

	return target, nil
}

type InterpGetPlan struct {
	Name                   string                 `json:"name,omitempty"`
	Type                   string                 `json:"type"`
	Resource               string                 `json:"resource"`
	Source                 Source                 `json:"source"`
	Params                 interpParams           `json:"params,omitempty"`
	Version                *Version               `json:"version,omitempty"`
	VersionFrom            *PlanID                `json:"version_from,omitempty"`
	Tags                   interpTags             `json:"tags,omitempty"`
	VersionedResourceTypes VersionedResourceTypes `json:"resource_types,omitempty"`
}

func (i InterpGetPlan) Interpolate(resolver interpolate.Resolver) (GetPlan, error) {
	target := GetPlan{
		Name:                   i.Name,
		Type:                   i.Type,
		Resource:               i.Resource,
		Source:                 i.Source,
		Version:                i.Version,
		VersionFrom:            i.VersionFrom,
		VersionedResourceTypes: i.VersionedResourceTypes,
	}
	var err error
	_ = err

	target.Params, err = i.Params.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Tags, err = i.Tags.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type interpParams struct {
	Val map[interpolate.String]interpInterface
	Ref interpolate.Var
}

func (i *interpParams) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

var _ json.Marshaler = new(interpParams)

func (i interpParams) Interpolate(resolver interpolate.Resolver) (Params, error) {
	if i.Ref != "" {
		var dst Params
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	if i.Val == nil {
		return nil, nil
	}
	target := Params{}
	for k, v := range i.Val {
		ki, err := k.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		vi, err := v.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		target[ki] = vi
	}
	return target, nil
}

type interpInterface struct {
	Val interface{}
	Ref interpolate.Var
}

func (i *interpInterface) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpInterface) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpInterface) Interpolate(resolver interpolate.Resolver) (interface{}, error) {
	if i.Ref != "" {
		var dst interface{}
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	return i.Val, nil
}

type interpTags struct {
	Val []interpolate.String
	Ref interpolate.Var
}

func (i *interpTags) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpTags) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpTags) Interpolate(resolver interpolate.Resolver) (Tags, error) {
	if i.Ref != "" {
		var dst Tags
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	if i.Val == nil {
		return nil, nil
	}

	target := make(Tags, len(i.Val))

	for i, v := range i.Val {
		vi, err := v.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		target[i] = vi
	}
	return target, nil
}

type InterpPutPlan struct {
	Type                   string                 `json:"type"`
	Name                   string                 `json:"name,omitempty"`
	Resource               string                 `json:"resource"`
	Source                 Source                 `json:"source"`
	Params                 interpParams           `json:"params,omitempty"`
	Tags                   interpTags             `json:"tags,omitempty"`
	Inputs                 *interpInputsConfig    `json:"inputs,omitempty"`
	VersionedResourceTypes VersionedResourceTypes `json:"resource_types,omitempty"`
}

func (i InterpPutPlan) Interpolate(resolver interpolate.Resolver) (PutPlan, error) {
	target := PutPlan{
		Type:                   i.Type,
		Name:                   i.Name,
		Resource:               i.Resource,
		Source:                 i.Source,
		VersionedResourceTypes: i.VersionedResourceTypes,
	}
	var err error
	_ = err

	target.Params, err = i.Params.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Tags, err = i.Tags.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	if i.Inputs != nil {
		v, err := i.Inputs.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.Inputs = &v
	}

	return target, nil
}

type interpInputsConfig struct {
	Val InputsConfig
	Ref interpolate.Var
}

func (i *interpInputsConfig) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpInputsConfig) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpInputsConfig) Interpolate(resolver interpolate.Resolver) (InputsConfig, error) {
	if i.Ref != "" {
		var dst InputsConfig
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	target := InputsConfig{
		All:       i.Val.All,
		Detect:    i.Val.Detect,
		Specified: i.Val.Specified,
	}
	var err error
	_ = err

	return target, nil
}

type InterpCheckPlan CheckPlan

func (i InterpCheckPlan) Interpolate(resolver interpolate.Resolver) (CheckPlan, error) {
	target := CheckPlan{
		Type:                   i.Type,
		Name:                   i.Name,
		Source:                 i.Source,
		Tags:                   i.Tags,
		Timeout:                i.Timeout,
		FromVersion:            i.FromVersion,
		VersionedResourceTypes: i.VersionedResourceTypes,
	}
	var err error
	_ = err

	return target, nil
}

type InterpTaskPlan struct {
	Name                   interpolate.String     `json:"name,omitempty"`
	Privileged             interpBool             `json:"privileged"`
	Tags                   interpTags             `json:"tags,omitempty"`
	ConfigPath             interpolate.String     `json:"config_path,omitempty"`
	Config                 *InterpTaskConfig      `json:"config,omitempty"`
	Vars                   interpParams           `json:"vars,omitempty"`
	Params                 interpParams           `json:"params,omitempty"`
	InputMapping           interpMap_400C0725     `json:"input_mapping,omitempty"`
	OutputMapping          interpMap_400C0725     `json:"output_mapping,omitempty"`
	ImageArtifactName      interpolate.String     `json:"image,omitempty"`
	VersionedResourceTypes VersionedResourceTypes `json:"resource_types,omitempty"`
}

func (i InterpTaskPlan) Interpolate(resolver interpolate.Resolver) (TaskPlan, error) {
	target := TaskPlan{
		VersionedResourceTypes: i.VersionedResourceTypes,
	}
	var err error
	_ = err

	target.Name, err = i.Name.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Privileged, err = i.Privileged.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Tags, err = i.Tags.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.ConfigPath, err = i.ConfigPath.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	if i.Config != nil {
		v, err := i.Config.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.Config = &v
	}

	target.Vars, err = i.Vars.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Params, err = i.Params.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.InputMapping, err = i.InputMapping.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.OutputMapping, err = i.OutputMapping.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.ImageArtifactName, err = i.ImageArtifactName.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type interpBool struct {
	Val bool
	Ref interpolate.Var
}

func (i *interpBool) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpBool) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpBool) Interpolate(resolver interpolate.Resolver) (bool, error) {
	if i.Ref != "" {
		var dst bool
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	return i.Val, nil
}

type InterpTaskConfig struct {
	Val struct {
		Platform      interpolate.String     `json:"platform,omitempty"`
		RootfsURI     interpolate.String     `json:"rootfs_uri,omitempty"`
		ImageResource *interpImageResource   `json:"image_resource,omitempty"`
		Limits        *interpContainerLimits `json:"container_limits,omitempty"`
		Params        interpTaskEnv          `json:"params,omitempty"`
		Run           interpTaskRunConfig    `json:"run,omitempty"`
		Inputs        interpSlice_3B1406B2   `json:"inputs,omitempty"`
		Outputs       interpSlice_43340733   `json:"outputs,omitempty"`
		Caches        interpSlice_390A0676   `json:"caches,omitempty"`
	}
	Ref interpolate.Var
}

func (i *InterpTaskConfig) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i InterpTaskConfig) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i InterpTaskConfig) Interpolate(resolver interpolate.Resolver) (TaskConfig, error) {
	if i.Ref != "" {
		var dst TaskConfig
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	target := TaskConfig{}
	var err error
	_ = err

	target.Platform, err = i.Val.Platform.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.RootfsURI, err = i.Val.RootfsURI.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	if i.Val.ImageResource != nil {
		v, err := i.Val.ImageResource.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.ImageResource = &v
	}

	if i.Val.Limits != nil {
		v, err := i.Val.Limits.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.Limits = &v
	}

	target.Params, err = i.Val.Params.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Run, err = i.Val.Run.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Inputs, err = i.Val.Inputs.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Outputs, err = i.Val.Outputs.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Caches, err = i.Val.Caches.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type interpImageResource struct {
	Val struct {
		Type    interpolate.String `json:"type"`
		Source  interpSource       `json:"source"`
		Params  interpParams       `json:"params,omitempty"`
		Version interpVersion      `json:"version,omitempty"`
	}
	Ref interpolate.Var
}

func (i *interpImageResource) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpImageResource) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpImageResource) Interpolate(resolver interpolate.Resolver) (ImageResource, error) {
	if i.Ref != "" {
		var dst ImageResource
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	target := ImageResource{}
	var err error
	_ = err

	target.Type, err = i.Val.Type.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Source, err = i.Val.Source.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Params, err = i.Val.Params.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Version, err = i.Val.Version.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type interpSource struct {
	Val map[interpolate.String]interpInterface
	Ref interpolate.Var
}

func (i *interpSource) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

var _ json.Marshaler = new(interpSource)

func (i interpSource) Interpolate(resolver interpolate.Resolver) (Source, error) {
	if i.Ref != "" {
		var dst Source
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	if i.Val == nil {
		return nil, nil
	}
	target := Source{}
	for k, v := range i.Val {
		ki, err := k.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		vi, err := v.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		target[ki] = vi
	}
	return target, nil
}

type interpVersion struct {
	Val map[interpolate.String]interpolate.String
	Ref interpolate.Var
}

func (i *interpVersion) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpVersion) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpVersion) Interpolate(resolver interpolate.Resolver) (Version, error) {
	if i.Ref != "" {
		var dst Version
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	if i.Val == nil {
		return nil, nil
	}
	target := Version{}
	for k, v := range i.Val {
		ki, err := k.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		vi, err := v.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		target[ki] = vi
	}
	return target, nil
}

type interpContainerLimits struct {
	Val struct {
		CPU    *interpCPULimit    `json:"cpu,omitempty"`
		Memory *interpMemoryLimit `json:"memory,omitempty"`
	}
	Ref interpolate.Var
}

func (i *interpContainerLimits) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpContainerLimits) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpContainerLimits) Interpolate(resolver interpolate.Resolver) (ContainerLimits, error) {
	if i.Ref != "" {
		var dst ContainerLimits
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	target := ContainerLimits{}
	var err error
	_ = err

	if i.Val.CPU != nil {
		v, err := i.Val.CPU.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.CPU = &v
	}

	if i.Val.Memory != nil {
		v, err := i.Val.Memory.Interpolate(resolver)
		if err != nil {
			return target, err
		}
		target.Memory = &v
	}

	return target, nil
}

type interpCPULimit struct {
	Val CPULimit
	Ref interpolate.Var
}

func (i *interpCPULimit) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpCPULimit) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpCPULimit) Interpolate(resolver interpolate.Resolver) (CPULimit, error) {
	if i.Ref != "" {
		var dst CPULimit
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	return i.Val, nil
}

type interpMemoryLimit struct {
	Val MemoryLimit
	Ref interpolate.Var
}

func (i *interpMemoryLimit) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpMemoryLimit) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpMemoryLimit) Interpolate(resolver interpolate.Resolver) (MemoryLimit, error) {
	if i.Ref != "" {
		var dst MemoryLimit
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	return i.Val, nil
}

type interpTaskEnv struct {
	Val map[interpolate.String]interpolate.String
	Ref interpolate.Var
}

var _ json.Unmarshaler = new(interpTaskEnv)

func (i interpTaskEnv) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpTaskEnv) Interpolate(resolver interpolate.Resolver) (TaskEnv, error) {
	if i.Ref != "" {
		var dst TaskEnv
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	if i.Val == nil {
		return nil, nil
	}
	target := TaskEnv{}
	for k, v := range i.Val {
		ki, err := k.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		vi, err := v.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		target[ki] = vi
	}
	return target, nil
}

type interpTaskRunConfig struct {
	Val struct {
		Path interpolate.String  `json:"path"`
		Args interpSlice_EA70350 `json:"args,omitempty"`
		Dir  interpolate.String  `json:"dir,omitempty"`
		User interpolate.String  `json:"user,omitempty"`
	}
	Ref interpolate.Var
}

func (i *interpTaskRunConfig) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpTaskRunConfig) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpTaskRunConfig) Interpolate(resolver interpolate.Resolver) (TaskRunConfig, error) {
	if i.Ref != "" {
		var dst TaskRunConfig
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	target := TaskRunConfig{}
	var err error
	_ = err

	target.Path, err = i.Val.Path.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Args, err = i.Val.Args.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Dir, err = i.Val.Dir.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.User, err = i.Val.User.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type interpSlice_EA70350 struct {
	Val []interpolate.String
	Ref interpolate.Var
}

func (i *interpSlice_EA70350) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpSlice_EA70350) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpSlice_EA70350) Interpolate(resolver interpolate.Resolver) ([]string, error) {
	if i.Ref != "" {
		var dst []string
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	if i.Val == nil {
		return nil, nil
	}

	target := make([]string, len(i.Val))

	for i, v := range i.Val {
		vi, err := v.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		target[i] = vi
	}
	return target, nil
}

type interpSlice_3B1406B2 struct {
	Val []interpTaskInputConfig
	Ref interpolate.Var
}

func (i *interpSlice_3B1406B2) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpSlice_3B1406B2) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpSlice_3B1406B2) Interpolate(resolver interpolate.Resolver) ([]TaskInputConfig, error) {
	if i.Ref != "" {
		var dst []TaskInputConfig
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	if i.Val == nil {
		return nil, nil
	}

	target := make([]TaskInputConfig, len(i.Val))

	for i, v := range i.Val {
		vi, err := v.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		target[i] = vi
	}
	return target, nil
}

type interpTaskInputConfig struct {
	Val struct {
		Name     interpolate.String `json:"name"`
		Path     interpolate.String `json:"path,omitempty"`
		Optional interpBool         `json:"optional,omitempty"`
	}
	Ref interpolate.Var
}

func (i *interpTaskInputConfig) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpTaskInputConfig) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpTaskInputConfig) Interpolate(resolver interpolate.Resolver) (TaskInputConfig, error) {
	if i.Ref != "" {
		var dst TaskInputConfig
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	target := TaskInputConfig{}
	var err error
	_ = err

	target.Name, err = i.Val.Name.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Path, err = i.Val.Path.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Optional, err = i.Val.Optional.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type interpSlice_43340733 struct {
	Val []interpTaskOutputConfig
	Ref interpolate.Var
}

func (i *interpSlice_43340733) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpSlice_43340733) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpSlice_43340733) Interpolate(resolver interpolate.Resolver) ([]TaskOutputConfig, error) {
	if i.Ref != "" {
		var dst []TaskOutputConfig
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	if i.Val == nil {
		return nil, nil
	}

	target := make([]TaskOutputConfig, len(i.Val))

	for i, v := range i.Val {
		vi, err := v.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		target[i] = vi
	}
	return target, nil
}

type interpTaskOutputConfig struct {
	Val struct {
		Name interpolate.String `json:"name"`
		Path interpolate.String `json:"path,omitempty"`
	}
	Ref interpolate.Var
}

func (i *interpTaskOutputConfig) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpTaskOutputConfig) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpTaskOutputConfig) Interpolate(resolver interpolate.Resolver) (TaskOutputConfig, error) {
	if i.Ref != "" {
		var dst TaskOutputConfig
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	target := TaskOutputConfig{}
	var err error
	_ = err

	target.Name, err = i.Val.Name.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Path, err = i.Val.Path.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type interpSlice_390A0676 struct {
	Val []interpTaskCacheConfig
	Ref interpolate.Var
}

func (i *interpSlice_390A0676) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpSlice_390A0676) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpSlice_390A0676) Interpolate(resolver interpolate.Resolver) ([]TaskCacheConfig, error) {
	if i.Ref != "" {
		var dst []TaskCacheConfig
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	if i.Val == nil {
		return nil, nil
	}

	target := make([]TaskCacheConfig, len(i.Val))

	for i, v := range i.Val {
		vi, err := v.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		target[i] = vi
	}
	return target, nil
}

type interpTaskCacheConfig struct {
	Val struct {
		Path interpolate.String `json:"path,omitempty"`
	}
	Ref interpolate.Var
}

func (i *interpTaskCacheConfig) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpTaskCacheConfig) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpTaskCacheConfig) Interpolate(resolver interpolate.Resolver) (TaskCacheConfig, error) {
	if i.Ref != "" {
		var dst TaskCacheConfig
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	target := TaskCacheConfig{}
	var err error
	_ = err

	target.Path, err = i.Val.Path.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type interpMap_400C0725 struct {
	Val map[interpolate.String]interpolate.String
	Ref interpolate.Var
}

func (i *interpMap_400C0725) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpMap_400C0725) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpMap_400C0725) Interpolate(resolver interpolate.Resolver) (map[string]string, error) {
	if i.Ref != "" {
		var dst map[string]string
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	if i.Val == nil {
		return nil, nil
	}
	target := map[string]string{}
	for k, v := range i.Val {
		ki, err := k.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		vi, err := v.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		target[ki] = vi
	}
	return target, nil
}

type InterpSetPipelinePlan struct {
	Name     interpolate.String  `json:"name"`
	File     interpolate.String  `json:"file"`
	Team     interpolate.String  `json:"team,omitempty"`
	Vars     interpMap_69360937  `json:"vars,omitempty"`
	VarFiles interpSlice_EA70350 `json:"var_files,omitempty"`
}

func (i InterpSetPipelinePlan) Interpolate(resolver interpolate.Resolver) (SetPipelinePlan, error) {
	target := SetPipelinePlan{}
	var err error
	_ = err

	target.Name, err = i.Name.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.File, err = i.File.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Team, err = i.Team.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Vars, err = i.Vars.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.VarFiles, err = i.VarFiles.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type interpMap_69360937 struct {
	Val map[interpolate.String]interpInterface
	Ref interpolate.Var
}

func (i *interpMap_69360937) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpMap_69360937) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpMap_69360937) Interpolate(resolver interpolate.Resolver) (map[string]interface{}, error) {
	if i.Ref != "" {
		var dst map[string]interface{}
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	if i.Val == nil {
		return nil, nil
	}
	target := map[string]interface{}{}
	for k, v := range i.Val {
		ki, err := k.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		vi, err := v.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		target[ki] = vi
	}
	return target, nil
}

type InterpLoadVarPlan struct {
	Name   interpolate.String `json:"name"`
	File   interpolate.String `json:"file"`
	Format interpolate.String `json:"format,omitempty"`
	Reveal interpBool         `json:"reveal,omitempty"`
}

func (i InterpLoadVarPlan) Interpolate(resolver interpolate.Resolver) (LoadVarPlan, error) {
	target := LoadVarPlan{}
	var err error
	_ = err

	target.Name, err = i.Name.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.File, err = i.File.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Format, err = i.Format.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Reveal, err = i.Reveal.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type InterpDoPlan []InterpPlan

func (i InterpDoPlan) Interpolate(resolver interpolate.Resolver) (DoPlan, error) {
	if i == nil {
		return nil, nil
	}

	target := make(DoPlan, len(i))

	for i, v := range i {
		vi, err := v.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		target[i] = vi
	}
	return target, nil
}

type InterpInParallelPlan struct {
	Steps    interpSlice_7AD0244 `json:"steps"`
	Limit    interpInt           `json:"limit,omitempty"`
	FailFast interpBool          `json:"fail_fast,omitempty"`
}

func (i InterpInParallelPlan) Interpolate(resolver interpolate.Resolver) (InParallelPlan, error) {
	target := InParallelPlan{}
	var err error
	_ = err

	target.Steps, err = i.Steps.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Limit, err = i.Limit.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.FailFast, err = i.FailFast.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type interpSlice_7AD0244 []InterpPlan

func (i interpSlice_7AD0244) Interpolate(resolver interpolate.Resolver) ([]Plan, error) {
	if i == nil {
		return nil, nil
	}

	target := make([]Plan, len(i))

	for i, v := range i {
		vi, err := v.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		target[i] = vi
	}
	return target, nil
}

type interpInt struct {
	Val int
	Ref interpolate.Var
}

func (i *interpInt) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i interpInt) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i interpInt) Interpolate(resolver interpolate.Resolver) (int, error) {
	if i.Ref != "" {
		var dst int
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	return i.Val, nil
}

type InterpAggregatePlan []InterpPlan

func (i InterpAggregatePlan) Interpolate(resolver interpolate.Resolver) (AggregatePlan, error) {
	if i == nil {
		return nil, nil
	}

	target := make(AggregatePlan, len(i))

	for i, v := range i {
		vi, err := v.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		target[i] = vi
	}
	return target, nil
}

type InterpAcrossPlan struct {
	Vars     interpSlice_18F0044D `json:"vars"`
	Steps    interpSlice_2D9105CB `json:"steps"`
	FailFast interpBool           `json:"fail_fast,omitempty"`
}

func (i InterpAcrossPlan) Interpolate(resolver interpolate.Resolver) (AcrossPlan, error) {
	target := AcrossPlan{}
	var err error
	_ = err

	target.Vars, err = i.Vars.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Steps, err = i.Steps.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.FailFast, err = i.FailFast.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type interpSlice_18F0044D []interpAcrossVar

func (i interpSlice_18F0044D) Interpolate(resolver interpolate.Resolver) ([]AcrossVar, error) {
	if i == nil {
		return nil, nil
	}

	target := make([]AcrossVar, len(i))

	for i, v := range i {
		vi, err := v.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		target[i] = vi
	}
	return target, nil
}

type interpAcrossVar struct {
	Var         string        `json:"name"`
	Values      []interface{} `json:"values"`
	MaxInFlight interpInt     `json:"max_in_flight"`
}

func (i interpAcrossVar) Interpolate(resolver interpolate.Resolver) (AcrossVar, error) {
	target := AcrossVar{
		Var:    i.Var,
		Values: i.Values,
	}
	var err error
	_ = err

	target.MaxInFlight, err = i.MaxInFlight.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type interpSlice_2D9105CB []interpVarScopedPlan

func (i interpSlice_2D9105CB) Interpolate(resolver interpolate.Resolver) ([]VarScopedPlan, error) {
	if i == nil {
		return nil, nil
	}

	target := make([]VarScopedPlan, len(i))

	for i, v := range i {
		vi, err := v.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		target[i] = vi
	}
	return target, nil
}

type interpVarScopedPlan struct {
	Step   InterpPlan    `json:"step"`
	Values []interface{} `json:"values"`
}

func (i interpVarScopedPlan) Interpolate(resolver interpolate.Resolver) (VarScopedPlan, error) {
	target := VarScopedPlan{
		Values: i.Values,
	}
	var err error
	_ = err

	target.Step, err = i.Step.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type InterpOnSuccessPlan struct {
	Step InterpPlan `json:"step"`
	Next InterpPlan `json:"on_success"`
}

func (i InterpOnSuccessPlan) Interpolate(resolver interpolate.Resolver) (OnSuccessPlan, error) {
	target := OnSuccessPlan{}
	var err error
	_ = err

	target.Step, err = i.Step.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Next, err = i.Next.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type InterpOnFailurePlan struct {
	Step InterpPlan `json:"step"`
	Next InterpPlan `json:"on_failure"`
}

func (i InterpOnFailurePlan) Interpolate(resolver interpolate.Resolver) (OnFailurePlan, error) {
	target := OnFailurePlan{}
	var err error
	_ = err

	target.Step, err = i.Step.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Next, err = i.Next.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type InterpOnAbortPlan struct {
	Step InterpPlan `json:"step"`
	Next InterpPlan `json:"on_abort"`
}

func (i InterpOnAbortPlan) Interpolate(resolver interpolate.Resolver) (OnAbortPlan, error) {
	target := OnAbortPlan{}
	var err error
	_ = err

	target.Step, err = i.Step.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Next, err = i.Next.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type InterpOnErrorPlan struct {
	Step InterpPlan `json:"step"`
	Next InterpPlan `json:"on_error"`
}

func (i InterpOnErrorPlan) Interpolate(resolver interpolate.Resolver) (OnErrorPlan, error) {
	target := OnErrorPlan{}
	var err error
	_ = err

	target.Step, err = i.Step.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Next, err = i.Next.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type InterpEnsurePlan struct {
	Step InterpPlan `json:"step"`
	Next InterpPlan `json:"ensure"`
}

func (i InterpEnsurePlan) Interpolate(resolver interpolate.Resolver) (EnsurePlan, error) {
	target := EnsurePlan{}
	var err error
	_ = err

	target.Step, err = i.Step.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Next, err = i.Next.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type InterpTryPlan struct {
	Step InterpPlan `json:"step"`
}

func (i InterpTryPlan) Interpolate(resolver interpolate.Resolver) (TryPlan, error) {
	target := TryPlan{}
	var err error
	_ = err

	target.Step, err = i.Step.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type InterpTimeoutPlan struct {
	Step     InterpPlan         `json:"step"`
	Duration interpolate.String `json:"duration"`
}

func (i InterpTimeoutPlan) Interpolate(resolver interpolate.Resolver) (TimeoutPlan, error) {
	target := TimeoutPlan{}
	var err error
	_ = err

	target.Step, err = i.Step.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	target.Duration, err = i.Duration.Interpolate(resolver)
	if err != nil {
		return target, err
	}

	return target, nil
}

type InterpRetryPlan []InterpPlan

func (i InterpRetryPlan) Interpolate(resolver interpolate.Resolver) (RetryPlan, error) {
	if i == nil {
		return nil, nil
	}

	target := make(RetryPlan, len(i))

	for i, v := range i {
		vi, err := v.Interpolate(resolver)
		if err != nil {
			return nil, err
		}
		target[i] = vi
	}
	return target, nil
}

type InterpDuration struct {
	Val Duration
	Ref interpolate.Var
}

func (i *InterpDuration) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &i.Ref); err == nil {
		return nil
	}
	return json.Unmarshal(data, &i.Val)
}

func (i InterpDuration) MarshalJSON() ([]byte, error) {
	if i.Ref != "" {
		return json.Marshal(i.Ref)
	}
	return json.Marshal(i.Val)
}

func (i InterpDuration) Interpolate(resolver interpolate.Resolver) (Duration, error) {
	if i.Ref != "" {
		var dst Duration
		err := i.Ref.InterpolateInto(resolver, &dst)
		return dst, err
	}
	return i.Val, nil
}
