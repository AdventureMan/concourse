// Code generated by github.com/concourse/concourse/vars/interp/interpgen. Do not modify!

package atc

import (
	"encoding/json"

	"github.com/concourse/concourse/vars/interp"
)

type InterpTaskConfig struct {
	I interface {
		Interpolate(interp.Resolver) (TaskConfig, error)
	}
}
type interpTaskConfigVar interp.Var

func (v TaskConfig) Interpolate(interp.Resolver) (TaskConfig, error) {
	return TaskConfig(v), nil
}
func (v TaskConfig) ToInterpolatable() InterpTaskConfig     { return InterpTaskConfig{I: v} }
func (v TaskConfig) ToInterpolatablePtr() *InterpTaskConfig { return &InterpTaskConfig{I: v} }
func (v interpTaskConfigVar) Interpolate(r interp.Resolver) (TaskConfig, error) {
	var dst TaskConfig
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i InterpTaskConfig) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *InterpTaskConfig) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpTaskConfigVar(v)
		return nil
	}
	var raw TaskConfig
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = TaskConfig(raw)
	return nil
}

type interpCPULimit struct {
	I interface {
		Interpolate(interp.Resolver) (CPULimit, error)
	}
}
type interpCPULimitVar interp.Var

func (v CPULimit) Interpolate(interp.Resolver) (CPULimit, error) {
	return CPULimit(v), nil
}
func (v CPULimit) ToInterpolatable() interpCPULimit     { return interpCPULimit{I: v} }
func (v CPULimit) ToInterpolatablePtr() *interpCPULimit { return &interpCPULimit{I: v} }
func (v interpCPULimitVar) Interpolate(r interp.Resolver) (CPULimit, error) {
	var dst CPULimit
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpCPULimit) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpCPULimit) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpCPULimitVar(v)
		return nil
	}
	var raw CPULimit
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = CPULimit(raw)
	return nil
}

type interpCoercedString struct {
	I interface {
		Interpolate(interp.Resolver) (CoercedString, error)
	}
}
type interpCoercedStringVar interp.Var

func (v CoercedString) Interpolate(interp.Resolver) (CoercedString, error) {
	return CoercedString(v), nil
}
func (v CoercedString) ToInterpolatable() interpCoercedString     { return interpCoercedString{I: v} }
func (v CoercedString) ToInterpolatablePtr() *interpCoercedString { return &interpCoercedString{I: v} }
func (v interpCoercedStringVar) Interpolate(r interp.Resolver) (CoercedString, error) {
	var dst CoercedString
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpCoercedString) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpCoercedString) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpCoercedStringVar(v)
		return nil
	}
	var raw CoercedString
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = CoercedString(raw)
	return nil
}

type interpContainerLimits struct {
	I interface {
		Interpolate(interp.Resolver) (ContainerLimits, error)
	}
}
type interpContainerLimitsVar interp.Var

func (v ContainerLimits) Interpolate(interp.Resolver) (ContainerLimits, error) {
	return ContainerLimits(v), nil
}
func (v ContainerLimits) ToInterpolatable() interpContainerLimits { return interpContainerLimits{I: v} }
func (v ContainerLimits) ToInterpolatablePtr() *interpContainerLimits {
	return &interpContainerLimits{I: v}
}
func (v interpContainerLimitsVar) Interpolate(r interp.Resolver) (ContainerLimits, error) {
	var dst ContainerLimits
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpContainerLimits) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpContainerLimits) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpContainerLimitsVar(v)
		return nil
	}
	var raw ContainerLimits
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = ContainerLimits(raw)
	return nil
}

type interpDuration struct {
	I interface {
		Interpolate(interp.Resolver) (Duration, error)
	}
}
type interpDurationVar interp.Var

func (v Duration) Interpolate(interp.Resolver) (Duration, error) {
	return Duration(v), nil
}
func (v Duration) ToInterpolatable() interpDuration     { return interpDuration{I: v} }
func (v Duration) ToInterpolatablePtr() *interpDuration { return &interpDuration{I: v} }
func (v interpDurationVar) Interpolate(r interp.Resolver) (Duration, error) {
	var dst Duration
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpDuration) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpDuration) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpDurationVar(v)
		return nil
	}
	var raw Duration
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = Duration(raw)
	return nil
}

type interpFileMapping struct {
	I interface {
		Interpolate(interp.Resolver) (FileMapping, error)
	}
}
type interpFileMappingVar interp.Var

func (v FileMapping) Interpolate(interp.Resolver) (FileMapping, error) {
	return FileMapping(v), nil
}
func (v FileMapping) ToInterpolatable() interpFileMapping     { return interpFileMapping{I: v} }
func (v FileMapping) ToInterpolatablePtr() *interpFileMapping { return &interpFileMapping{I: v} }
func (v interpFileMappingVar) Interpolate(r interp.Resolver) (FileMapping, error) {
	var dst FileMapping
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpFileMapping) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpFileMapping) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpFileMappingVar(v)
		return nil
	}
	var raw FileMapping
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = FileMapping(raw)
	return nil
}

type interpImageResource struct {
	I interface {
		Interpolate(interp.Resolver) (ImageResource, error)
	}
}
type interpImageResourceVar interp.Var

func (v ImageResource) Interpolate(interp.Resolver) (ImageResource, error) {
	return ImageResource(v), nil
}
func (v ImageResource) ToInterpolatable() interpImageResource     { return interpImageResource{I: v} }
func (v ImageResource) ToInterpolatablePtr() *interpImageResource { return &interpImageResource{I: v} }
func (v interpImageResourceVar) Interpolate(r interp.Resolver) (ImageResource, error) {
	var dst ImageResource
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpImageResource) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpImageResource) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpImageResourceVar(v)
		return nil
	}
	var raw ImageResource
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = ImageResource(raw)
	return nil
}

type interpInputsConfig struct {
	I interface {
		Interpolate(interp.Resolver) (InputsConfig, error)
	}
}
type interpInputsConfigVar interp.Var

func (v InputsConfig) Interpolate(interp.Resolver) (InputsConfig, error) {
	return InputsConfig(v), nil
}
func (v InputsConfig) ToInterpolatable() interpInputsConfig     { return interpInputsConfig{I: v} }
func (v InputsConfig) ToInterpolatablePtr() *interpInputsConfig { return &interpInputsConfig{I: v} }
func (v interpInputsConfigVar) Interpolate(r interp.Resolver) (InputsConfig, error) {
	var dst InputsConfig
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpInputsConfig) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpInputsConfig) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpInputsConfigVar(v)
		return nil
	}
	var raw InputsConfig
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = InputsConfig(raw)
	return nil
}

type interpMaxInFlightConfig struct {
	I interface {
		Interpolate(interp.Resolver) (MaxInFlightConfig, error)
	}
}
type interpMaxInFlightConfigVar interp.Var

func (v MaxInFlightConfig) Interpolate(interp.Resolver) (MaxInFlightConfig, error) {
	return MaxInFlightConfig(v), nil
}
func (v MaxInFlightConfig) ToInterpolatable() interpMaxInFlightConfig {
	return interpMaxInFlightConfig{I: v}
}
func (v MaxInFlightConfig) ToInterpolatablePtr() *interpMaxInFlightConfig {
	return &interpMaxInFlightConfig{I: v}
}
func (v interpMaxInFlightConfigVar) Interpolate(r interp.Resolver) (MaxInFlightConfig, error) {
	var dst MaxInFlightConfig
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpMaxInFlightConfig) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpMaxInFlightConfig) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpMaxInFlightConfigVar(v)
		return nil
	}
	var raw MaxInFlightConfig
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = MaxInFlightConfig(raw)
	return nil
}

type interpMemoryLimit struct {
	I interface {
		Interpolate(interp.Resolver) (MemoryLimit, error)
	}
}
type interpMemoryLimitVar interp.Var

func (v MemoryLimit) Interpolate(interp.Resolver) (MemoryLimit, error) {
	return MemoryLimit(v), nil
}
func (v MemoryLimit) ToInterpolatable() interpMemoryLimit     { return interpMemoryLimit{I: v} }
func (v MemoryLimit) ToInterpolatablePtr() *interpMemoryLimit { return &interpMemoryLimit{I: v} }
func (v interpMemoryLimitVar) Interpolate(r interp.Resolver) (MemoryLimit, error) {
	var dst MemoryLimit
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpMemoryLimit) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpMemoryLimit) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpMemoryLimitVar(v)
		return nil
	}
	var raw MemoryLimit
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = MemoryLimit(raw)
	return nil
}

type interpParams struct {
	I interface {
		Interpolate(interp.Resolver) (Params, error)
	}
}
type interpParamsVar interp.Var

func (v Params) Interpolate(interp.Resolver) (Params, error) {
	return Params(v), nil
}
func (v Params) ToInterpolatable() interpParams     { return interpParams{I: v} }
func (v Params) ToInterpolatablePtr() *interpParams { return &interpParams{I: v} }
func (v interpParamsVar) Interpolate(r interp.Resolver) (Params, error) {
	var dst Params
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpParams) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpParams) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpParamsVar(v)
		return nil
	}
	var raw Params
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = Params(raw)
	return nil
}

type interpSource struct {
	I interface {
		Interpolate(interp.Resolver) (Source, error)
	}
}
type interpSourceVar interp.Var

func (v Source) Interpolate(interp.Resolver) (Source, error) {
	return Source(v), nil
}
func (v Source) ToInterpolatable() interpSource     { return interpSource{I: v} }
func (v Source) ToInterpolatablePtr() *interpSource { return &interpSource{I: v} }
func (v interpSourceVar) Interpolate(r interp.Resolver) (Source, error) {
	var dst Source
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpSource) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpSource) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpSourceVar(v)
		return nil
	}
	var raw Source
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = Source(raw)
	return nil
}

type interpStringList struct {
	I interface {
		Interpolate(interp.Resolver) (stringList, error)
	}
}
type interpStringListVar interp.Var

func (v stringList) Interpolate(interp.Resolver) (stringList, error) {
	return stringList(v), nil
}
func (v stringList) ToInterpolatable() interpStringList     { return interpStringList{I: v} }
func (v stringList) ToInterpolatablePtr() *interpStringList { return &interpStringList{I: v} }
func (v interpStringListVar) Interpolate(r interp.Resolver) (stringList, error) {
	var dst stringList
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpStringList) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpStringList) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpStringListVar(v)
		return nil
	}
	var raw stringList
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = stringList(raw)
	return nil
}

type interpTags struct {
	I interface {
		Interpolate(interp.Resolver) (Tags, error)
	}
}
type interpTagsVar interp.Var

func (v Tags) Interpolate(interp.Resolver) (Tags, error) {
	return Tags(v), nil
}
func (v Tags) ToInterpolatable() interpTags     { return interpTags{I: v} }
func (v Tags) ToInterpolatablePtr() *interpTags { return &interpTags{I: v} }
func (v interpTagsVar) Interpolate(r interp.Resolver) (Tags, error) {
	var dst Tags
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpTags) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpTags) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpTagsVar(v)
		return nil
	}
	var raw Tags
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = Tags(raw)
	return nil
}

type interpTaskCacheConfig struct {
	I interface {
		Interpolate(interp.Resolver) (TaskCacheConfig, error)
	}
}
type interpTaskCacheConfigVar interp.Var

func (v TaskCacheConfig) Interpolate(interp.Resolver) (TaskCacheConfig, error) {
	return TaskCacheConfig(v), nil
}
func (v TaskCacheConfig) ToInterpolatable() interpTaskCacheConfig { return interpTaskCacheConfig{I: v} }
func (v TaskCacheConfig) ToInterpolatablePtr() *interpTaskCacheConfig {
	return &interpTaskCacheConfig{I: v}
}
func (v interpTaskCacheConfigVar) Interpolate(r interp.Resolver) (TaskCacheConfig, error) {
	var dst TaskCacheConfig
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpTaskCacheConfig) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpTaskCacheConfig) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpTaskCacheConfigVar(v)
		return nil
	}
	var raw TaskCacheConfig
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = TaskCacheConfig(raw)
	return nil
}

type interpTaskCacheConfigs struct {
	I interface {
		Interpolate(interp.Resolver) (TaskCacheConfigs, error)
	}
}
type interpTaskCacheConfigsVar interp.Var

func (v TaskCacheConfigs) Interpolate(interp.Resolver) (TaskCacheConfigs, error) {
	return TaskCacheConfigs(v), nil
}
func (v TaskCacheConfigs) ToInterpolatable() interpTaskCacheConfigs {
	return interpTaskCacheConfigs{I: v}
}
func (v TaskCacheConfigs) ToInterpolatablePtr() *interpTaskCacheConfigs {
	return &interpTaskCacheConfigs{I: v}
}
func (v interpTaskCacheConfigsVar) Interpolate(r interp.Resolver) (TaskCacheConfigs, error) {
	var dst TaskCacheConfigs
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpTaskCacheConfigs) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpTaskCacheConfigs) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpTaskCacheConfigsVar(v)
		return nil
	}
	var raw TaskCacheConfigs
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = TaskCacheConfigs(raw)
	return nil
}

type interpTaskEnv struct {
	I interface {
		Interpolate(interp.Resolver) (TaskEnv, error)
	}
}
type interpTaskEnvVar interp.Var

func (v TaskEnv) Interpolate(interp.Resolver) (TaskEnv, error) {
	return TaskEnv(v), nil
}
func (v TaskEnv) ToInterpolatable() interpTaskEnv     { return interpTaskEnv{I: v} }
func (v TaskEnv) ToInterpolatablePtr() *interpTaskEnv { return &interpTaskEnv{I: v} }
func (v interpTaskEnvVar) Interpolate(r interp.Resolver) (TaskEnv, error) {
	var dst TaskEnv
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpTaskEnv) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpTaskEnv) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpTaskEnvVar(v)
		return nil
	}
	var raw TaskEnv
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = TaskEnv(raw)
	return nil
}

type interpTaskInputConfig struct {
	I interface {
		Interpolate(interp.Resolver) (TaskInputConfig, error)
	}
}
type interpTaskInputConfigVar interp.Var

func (v TaskInputConfig) Interpolate(interp.Resolver) (TaskInputConfig, error) {
	return TaskInputConfig(v), nil
}
func (v TaskInputConfig) ToInterpolatable() interpTaskInputConfig { return interpTaskInputConfig{I: v} }
func (v TaskInputConfig) ToInterpolatablePtr() *interpTaskInputConfig {
	return &interpTaskInputConfig{I: v}
}
func (v interpTaskInputConfigVar) Interpolate(r interp.Resolver) (TaskInputConfig, error) {
	var dst TaskInputConfig
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpTaskInputConfig) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpTaskInputConfig) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpTaskInputConfigVar(v)
		return nil
	}
	var raw TaskInputConfig
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = TaskInputConfig(raw)
	return nil
}

type interpTaskInputConfigs struct {
	I interface {
		Interpolate(interp.Resolver) (TaskInputConfigs, error)
	}
}
type interpTaskInputConfigsVar interp.Var

func (v TaskInputConfigs) Interpolate(interp.Resolver) (TaskInputConfigs, error) {
	return TaskInputConfigs(v), nil
}
func (v TaskInputConfigs) ToInterpolatable() interpTaskInputConfigs {
	return interpTaskInputConfigs{I: v}
}
func (v TaskInputConfigs) ToInterpolatablePtr() *interpTaskInputConfigs {
	return &interpTaskInputConfigs{I: v}
}
func (v interpTaskInputConfigsVar) Interpolate(r interp.Resolver) (TaskInputConfigs, error) {
	var dst TaskInputConfigs
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpTaskInputConfigs) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpTaskInputConfigs) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpTaskInputConfigsVar(v)
		return nil
	}
	var raw TaskInputConfigs
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = TaskInputConfigs(raw)
	return nil
}

type interpTaskOutputConfig struct {
	I interface {
		Interpolate(interp.Resolver) (TaskOutputConfig, error)
	}
}
type interpTaskOutputConfigVar interp.Var

func (v TaskOutputConfig) Interpolate(interp.Resolver) (TaskOutputConfig, error) {
	return TaskOutputConfig(v), nil
}
func (v TaskOutputConfig) ToInterpolatable() interpTaskOutputConfig {
	return interpTaskOutputConfig{I: v}
}
func (v TaskOutputConfig) ToInterpolatablePtr() *interpTaskOutputConfig {
	return &interpTaskOutputConfig{I: v}
}
func (v interpTaskOutputConfigVar) Interpolate(r interp.Resolver) (TaskOutputConfig, error) {
	var dst TaskOutputConfig
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpTaskOutputConfig) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpTaskOutputConfig) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpTaskOutputConfigVar(v)
		return nil
	}
	var raw TaskOutputConfig
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = TaskOutputConfig(raw)
	return nil
}

type interpTaskOutputConfigs struct {
	I interface {
		Interpolate(interp.Resolver) (TaskOutputConfigs, error)
	}
}
type interpTaskOutputConfigsVar interp.Var

func (v TaskOutputConfigs) Interpolate(interp.Resolver) (TaskOutputConfigs, error) {
	return TaskOutputConfigs(v), nil
}
func (v TaskOutputConfigs) ToInterpolatable() interpTaskOutputConfigs {
	return interpTaskOutputConfigs{I: v}
}
func (v TaskOutputConfigs) ToInterpolatablePtr() *interpTaskOutputConfigs {
	return &interpTaskOutputConfigs{I: v}
}
func (v interpTaskOutputConfigsVar) Interpolate(r interp.Resolver) (TaskOutputConfigs, error) {
	var dst TaskOutputConfigs
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpTaskOutputConfigs) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpTaskOutputConfigs) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpTaskOutputConfigsVar(v)
		return nil
	}
	var raw TaskOutputConfigs
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = TaskOutputConfigs(raw)
	return nil
}

type interpTaskRunConfig struct {
	I interface {
		Interpolate(interp.Resolver) (TaskRunConfig, error)
	}
}
type interpTaskRunConfigVar interp.Var

func (v TaskRunConfig) Interpolate(interp.Resolver) (TaskRunConfig, error) {
	return TaskRunConfig(v), nil
}
func (v TaskRunConfig) ToInterpolatable() interpTaskRunConfig     { return interpTaskRunConfig{I: v} }
func (v TaskRunConfig) ToInterpolatablePtr() *interpTaskRunConfig { return &interpTaskRunConfig{I: v} }
func (v interpTaskRunConfigVar) Interpolate(r interp.Resolver) (TaskRunConfig, error) {
	var dst TaskRunConfig
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpTaskRunConfig) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpTaskRunConfig) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpTaskRunConfigVar(v)
		return nil
	}
	var raw TaskRunConfig
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = TaskRunConfig(raw)
	return nil
}

type interpVersion struct {
	I interface {
		Interpolate(interp.Resolver) (Version, error)
	}
}
type interpVersionVar interp.Var

func (v Version) Interpolate(interp.Resolver) (Version, error) {
	return Version(v), nil
}
func (v Version) ToInterpolatable() interpVersion     { return interpVersion{I: v} }
func (v Version) ToInterpolatablePtr() *interpVersion { return &interpVersion{I: v} }
func (v interpVersionVar) Interpolate(r interp.Resolver) (Version, error) {
	var dst Version
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i interpVersion) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *interpVersion) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = interpVersionVar(v)
		return nil
	}
	var raw Version
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = Version(raw)
	return nil
}
