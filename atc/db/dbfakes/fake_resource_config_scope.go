// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/concourse/atc"
	"github.com/concourse/concourse/atc/db"
	"github.com/concourse/concourse/atc/db/lock"
)

type FakeResourceConfigScope struct {
	AcquireResourceCheckingLockStub        func(lager.Logger, time.Duration) (lock.Lock, bool, error)
	acquireResourceCheckingLockMutex       sync.RWMutex
	acquireResourceCheckingLockArgsForCall []struct {
		arg1 lager.Logger
		arg2 time.Duration
	}
	acquireResourceCheckingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireResourceCheckingLockReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	CheckErrorStub        func() error
	checkErrorMutex       sync.RWMutex
	checkErrorArgsForCall []struct {
	}
	checkErrorReturns struct {
		result1 error
	}
	checkErrorReturnsOnCall map[int]struct {
		result1 error
	}
	DefaultSpaceStub        func() atc.Space
	defaultSpaceMutex       sync.RWMutex
	defaultSpaceArgsForCall []struct {
	}
	defaultSpaceReturns struct {
		result1 atc.Space
	}
	defaultSpaceReturnsOnCall map[int]struct {
		result1 atc.Space
	}
	FindUncheckedVersionStub        func(atc.Space, atc.Version) (db.ResourceVersion, bool, error)
	findUncheckedVersionMutex       sync.RWMutex
	findUncheckedVersionArgsForCall []struct {
		arg1 atc.Space
		arg2 atc.Version
	}
	findUncheckedVersionReturns struct {
		result1 db.ResourceVersion
		result2 bool
		result3 error
	}
	findUncheckedVersionReturnsOnCall map[int]struct {
		result1 db.ResourceVersion
		result2 bool
		result3 error
	}
	FindVersionStub        func(atc.Space, atc.Version) (db.ResourceVersion, bool, error)
	findVersionMutex       sync.RWMutex
	findVersionArgsForCall []struct {
		arg1 atc.Space
		arg2 atc.Version
	}
	findVersionReturns struct {
		result1 db.ResourceVersion
		result2 bool
		result3 error
	}
	findVersionReturnsOnCall map[int]struct {
		result1 db.ResourceVersion
		result2 bool
		result3 error
	}
	FinishSavingVersionsStub        func() error
	finishSavingVersionsMutex       sync.RWMutex
	finishSavingVersionsArgsForCall []struct {
	}
	finishSavingVersionsReturns struct {
		result1 error
	}
	finishSavingVersionsReturnsOnCall map[int]struct {
		result1 error
	}
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	LatestVersionsStub        func() ([]db.ResourceVersion, error)
	latestVersionsMutex       sync.RWMutex
	latestVersionsArgsForCall []struct {
	}
	latestVersionsReturns struct {
		result1 []db.ResourceVersion
		result2 error
	}
	latestVersionsReturnsOnCall map[int]struct {
		result1 []db.ResourceVersion
		result2 error
	}
	ResourceStub        func() db.Resource
	resourceMutex       sync.RWMutex
	resourceArgsForCall []struct {
	}
	resourceReturns struct {
		result1 db.Resource
	}
	resourceReturnsOnCall map[int]struct {
		result1 db.Resource
	}
	ResourceConfigStub        func() db.ResourceConfig
	resourceConfigMutex       sync.RWMutex
	resourceConfigArgsForCall []struct {
	}
	resourceConfigReturns struct {
		result1 db.ResourceConfig
	}
	resourceConfigReturnsOnCall map[int]struct {
		result1 db.ResourceConfig
	}
	SaveDefaultSpaceStub        func(atc.Space) error
	saveDefaultSpaceMutex       sync.RWMutex
	saveDefaultSpaceArgsForCall []struct {
		arg1 atc.Space
	}
	saveDefaultSpaceReturns struct {
		result1 error
	}
	saveDefaultSpaceReturnsOnCall map[int]struct {
		result1 error
	}
	SavePartialVersionStub        func(atc.Space, atc.Version, atc.Metadata) error
	savePartialVersionMutex       sync.RWMutex
	savePartialVersionArgsForCall []struct {
		arg1 atc.Space
		arg2 atc.Version
		arg3 atc.Metadata
	}
	savePartialVersionReturns struct {
		result1 error
	}
	savePartialVersionReturnsOnCall map[int]struct {
		result1 error
	}
	SaveSpaceStub        func(atc.Space) error
	saveSpaceMutex       sync.RWMutex
	saveSpaceArgsForCall []struct {
		arg1 atc.Space
	}
	saveSpaceReturns struct {
		result1 error
	}
	saveSpaceReturnsOnCall map[int]struct {
		result1 error
	}
	SaveSpaceLatestVersionStub        func(atc.Space, atc.Version) error
	saveSpaceLatestVersionMutex       sync.RWMutex
	saveSpaceLatestVersionArgsForCall []struct {
		arg1 atc.Space
		arg2 atc.Version
	}
	saveSpaceLatestVersionReturns struct {
		result1 error
	}
	saveSpaceLatestVersionReturnsOnCall map[int]struct {
		result1 error
	}
	SaveUncheckedVersionStub        func(atc.Space, atc.Version, db.ResourceConfigMetadataFields) (bool, error)
	saveUncheckedVersionMutex       sync.RWMutex
	saveUncheckedVersionArgsForCall []struct {
		arg1 atc.Space
		arg2 atc.Version
		arg3 db.ResourceConfigMetadataFields
	}
	saveUncheckedVersionReturns struct {
		result1 bool
		result2 error
	}
	saveUncheckedVersionReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	SetCheckErrorStub        func(error) error
	setCheckErrorMutex       sync.RWMutex
	setCheckErrorArgsForCall []struct {
		arg1 error
	}
	setCheckErrorReturns struct {
		result1 error
	}
	setCheckErrorReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateLastCheckFinishedStub        func() (bool, error)
	updateLastCheckFinishedMutex       sync.RWMutex
	updateLastCheckFinishedArgsForCall []struct {
	}
	updateLastCheckFinishedReturns struct {
		result1 bool
		result2 error
	}
	updateLastCheckFinishedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	UpdateLastCheckedStub        func(time.Duration, bool) (bool, error)
	updateLastCheckedMutex       sync.RWMutex
	updateLastCheckedArgsForCall []struct {
		arg1 time.Duration
		arg2 bool
	}
	updateLastCheckedReturns struct {
		result1 bool
		result2 error
	}
	updateLastCheckedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeResourceConfigScope) AcquireResourceCheckingLock(arg1 lager.Logger, arg2 time.Duration) (lock.Lock, bool, error) {
	fake.acquireResourceCheckingLockMutex.Lock()
	ret, specificReturn := fake.acquireResourceCheckingLockReturnsOnCall[len(fake.acquireResourceCheckingLockArgsForCall)]
	fake.acquireResourceCheckingLockArgsForCall = append(fake.acquireResourceCheckingLockArgsForCall, struct {
		arg1 lager.Logger
		arg2 time.Duration
	}{arg1, arg2})
	fake.recordInvocation("AcquireResourceCheckingLock", []interface{}{arg1, arg2})
	fake.acquireResourceCheckingLockMutex.Unlock()
	if fake.AcquireResourceCheckingLockStub != nil {
		return fake.AcquireResourceCheckingLockStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.acquireResourceCheckingLockReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeResourceConfigScope) AcquireResourceCheckingLockCallCount() int {
	fake.acquireResourceCheckingLockMutex.RLock()
	defer fake.acquireResourceCheckingLockMutex.RUnlock()
	return len(fake.acquireResourceCheckingLockArgsForCall)
}

func (fake *FakeResourceConfigScope) AcquireResourceCheckingLockCalls(stub func(lager.Logger, time.Duration) (lock.Lock, bool, error)) {
	fake.acquireResourceCheckingLockMutex.Lock()
	defer fake.acquireResourceCheckingLockMutex.Unlock()
	fake.AcquireResourceCheckingLockStub = stub
}

func (fake *FakeResourceConfigScope) AcquireResourceCheckingLockArgsForCall(i int) (lager.Logger, time.Duration) {
	fake.acquireResourceCheckingLockMutex.RLock()
	defer fake.acquireResourceCheckingLockMutex.RUnlock()
	argsForCall := fake.acquireResourceCheckingLockArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceConfigScope) AcquireResourceCheckingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.acquireResourceCheckingLockMutex.Lock()
	defer fake.acquireResourceCheckingLockMutex.Unlock()
	fake.AcquireResourceCheckingLockStub = nil
	fake.acquireResourceCheckingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResourceConfigScope) AcquireResourceCheckingLockReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.acquireResourceCheckingLockMutex.Lock()
	defer fake.acquireResourceCheckingLockMutex.Unlock()
	fake.AcquireResourceCheckingLockStub = nil
	if fake.acquireResourceCheckingLockReturnsOnCall == nil {
		fake.acquireResourceCheckingLockReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireResourceCheckingLockReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResourceConfigScope) CheckError() error {
	fake.checkErrorMutex.Lock()
	ret, specificReturn := fake.checkErrorReturnsOnCall[len(fake.checkErrorArgsForCall)]
	fake.checkErrorArgsForCall = append(fake.checkErrorArgsForCall, struct {
	}{})
	fake.recordInvocation("CheckError", []interface{}{})
	fake.checkErrorMutex.Unlock()
	if fake.CheckErrorStub != nil {
		return fake.CheckErrorStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.checkErrorReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfigScope) CheckErrorCallCount() int {
	fake.checkErrorMutex.RLock()
	defer fake.checkErrorMutex.RUnlock()
	return len(fake.checkErrorArgsForCall)
}

func (fake *FakeResourceConfigScope) CheckErrorCalls(stub func() error) {
	fake.checkErrorMutex.Lock()
	defer fake.checkErrorMutex.Unlock()
	fake.CheckErrorStub = stub
}

func (fake *FakeResourceConfigScope) CheckErrorReturns(result1 error) {
	fake.checkErrorMutex.Lock()
	defer fake.checkErrorMutex.Unlock()
	fake.CheckErrorStub = nil
	fake.checkErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfigScope) CheckErrorReturnsOnCall(i int, result1 error) {
	fake.checkErrorMutex.Lock()
	defer fake.checkErrorMutex.Unlock()
	fake.CheckErrorStub = nil
	if fake.checkErrorReturnsOnCall == nil {
		fake.checkErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfigScope) DefaultSpace() atc.Space {
	fake.defaultSpaceMutex.Lock()
	ret, specificReturn := fake.defaultSpaceReturnsOnCall[len(fake.defaultSpaceArgsForCall)]
	fake.defaultSpaceArgsForCall = append(fake.defaultSpaceArgsForCall, struct {
	}{})
	fake.recordInvocation("DefaultSpace", []interface{}{})
	fake.defaultSpaceMutex.Unlock()
	if fake.DefaultSpaceStub != nil {
		return fake.DefaultSpaceStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.defaultSpaceReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfigScope) DefaultSpaceCallCount() int {
	fake.defaultSpaceMutex.RLock()
	defer fake.defaultSpaceMutex.RUnlock()
	return len(fake.defaultSpaceArgsForCall)
}

func (fake *FakeResourceConfigScope) DefaultSpaceCalls(stub func() atc.Space) {
	fake.defaultSpaceMutex.Lock()
	defer fake.defaultSpaceMutex.Unlock()
	fake.DefaultSpaceStub = stub
}

func (fake *FakeResourceConfigScope) DefaultSpaceReturns(result1 atc.Space) {
	fake.defaultSpaceMutex.Lock()
	defer fake.defaultSpaceMutex.Unlock()
	fake.DefaultSpaceStub = nil
	fake.defaultSpaceReturns = struct {
		result1 atc.Space
	}{result1}
}

func (fake *FakeResourceConfigScope) DefaultSpaceReturnsOnCall(i int, result1 atc.Space) {
	fake.defaultSpaceMutex.Lock()
	defer fake.defaultSpaceMutex.Unlock()
	fake.DefaultSpaceStub = nil
	if fake.defaultSpaceReturnsOnCall == nil {
		fake.defaultSpaceReturnsOnCall = make(map[int]struct {
			result1 atc.Space
		})
	}
	fake.defaultSpaceReturnsOnCall[i] = struct {
		result1 atc.Space
	}{result1}
}

func (fake *FakeResourceConfigScope) FindUncheckedVersion(arg1 atc.Space, arg2 atc.Version) (db.ResourceVersion, bool, error) {
	fake.findUncheckedVersionMutex.Lock()
	ret, specificReturn := fake.findUncheckedVersionReturnsOnCall[len(fake.findUncheckedVersionArgsForCall)]
	fake.findUncheckedVersionArgsForCall = append(fake.findUncheckedVersionArgsForCall, struct {
		arg1 atc.Space
		arg2 atc.Version
	}{arg1, arg2})
	fake.recordInvocation("FindUncheckedVersion", []interface{}{arg1, arg2})
	fake.findUncheckedVersionMutex.Unlock()
	if fake.FindUncheckedVersionStub != nil {
		return fake.FindUncheckedVersionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.findUncheckedVersionReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeResourceConfigScope) FindUncheckedVersionCallCount() int {
	fake.findUncheckedVersionMutex.RLock()
	defer fake.findUncheckedVersionMutex.RUnlock()
	return len(fake.findUncheckedVersionArgsForCall)
}

func (fake *FakeResourceConfigScope) FindUncheckedVersionCalls(stub func(atc.Space, atc.Version) (db.ResourceVersion, bool, error)) {
	fake.findUncheckedVersionMutex.Lock()
	defer fake.findUncheckedVersionMutex.Unlock()
	fake.FindUncheckedVersionStub = stub
}

func (fake *FakeResourceConfigScope) FindUncheckedVersionArgsForCall(i int) (atc.Space, atc.Version) {
	fake.findUncheckedVersionMutex.RLock()
	defer fake.findUncheckedVersionMutex.RUnlock()
	argsForCall := fake.findUncheckedVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceConfigScope) FindUncheckedVersionReturns(result1 db.ResourceVersion, result2 bool, result3 error) {
	fake.findUncheckedVersionMutex.Lock()
	defer fake.findUncheckedVersionMutex.Unlock()
	fake.FindUncheckedVersionStub = nil
	fake.findUncheckedVersionReturns = struct {
		result1 db.ResourceVersion
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResourceConfigScope) FindUncheckedVersionReturnsOnCall(i int, result1 db.ResourceVersion, result2 bool, result3 error) {
	fake.findUncheckedVersionMutex.Lock()
	defer fake.findUncheckedVersionMutex.Unlock()
	fake.FindUncheckedVersionStub = nil
	if fake.findUncheckedVersionReturnsOnCall == nil {
		fake.findUncheckedVersionReturnsOnCall = make(map[int]struct {
			result1 db.ResourceVersion
			result2 bool
			result3 error
		})
	}
	fake.findUncheckedVersionReturnsOnCall[i] = struct {
		result1 db.ResourceVersion
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResourceConfigScope) FindVersion(arg1 atc.Space, arg2 atc.Version) (db.ResourceVersion, bool, error) {
	fake.findVersionMutex.Lock()
	ret, specificReturn := fake.findVersionReturnsOnCall[len(fake.findVersionArgsForCall)]
	fake.findVersionArgsForCall = append(fake.findVersionArgsForCall, struct {
		arg1 atc.Space
		arg2 atc.Version
	}{arg1, arg2})
	fake.recordInvocation("FindVersion", []interface{}{arg1, arg2})
	fake.findVersionMutex.Unlock()
	if fake.FindVersionStub != nil {
		return fake.FindVersionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.findVersionReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeResourceConfigScope) FindVersionCallCount() int {
	fake.findVersionMutex.RLock()
	defer fake.findVersionMutex.RUnlock()
	return len(fake.findVersionArgsForCall)
}

func (fake *FakeResourceConfigScope) FindVersionCalls(stub func(atc.Space, atc.Version) (db.ResourceVersion, bool, error)) {
	fake.findVersionMutex.Lock()
	defer fake.findVersionMutex.Unlock()
	fake.FindVersionStub = stub
}

func (fake *FakeResourceConfigScope) FindVersionArgsForCall(i int) (atc.Space, atc.Version) {
	fake.findVersionMutex.RLock()
	defer fake.findVersionMutex.RUnlock()
	argsForCall := fake.findVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceConfigScope) FindVersionReturns(result1 db.ResourceVersion, result2 bool, result3 error) {
	fake.findVersionMutex.Lock()
	defer fake.findVersionMutex.Unlock()
	fake.FindVersionStub = nil
	fake.findVersionReturns = struct {
		result1 db.ResourceVersion
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResourceConfigScope) FindVersionReturnsOnCall(i int, result1 db.ResourceVersion, result2 bool, result3 error) {
	fake.findVersionMutex.Lock()
	defer fake.findVersionMutex.Unlock()
	fake.FindVersionStub = nil
	if fake.findVersionReturnsOnCall == nil {
		fake.findVersionReturnsOnCall = make(map[int]struct {
			result1 db.ResourceVersion
			result2 bool
			result3 error
		})
	}
	fake.findVersionReturnsOnCall[i] = struct {
		result1 db.ResourceVersion
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResourceConfigScope) FinishSavingVersions() error {
	fake.finishSavingVersionsMutex.Lock()
	ret, specificReturn := fake.finishSavingVersionsReturnsOnCall[len(fake.finishSavingVersionsArgsForCall)]
	fake.finishSavingVersionsArgsForCall = append(fake.finishSavingVersionsArgsForCall, struct {
	}{})
	fake.recordInvocation("FinishSavingVersions", []interface{}{})
	fake.finishSavingVersionsMutex.Unlock()
	if fake.FinishSavingVersionsStub != nil {
		return fake.FinishSavingVersionsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.finishSavingVersionsReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfigScope) FinishSavingVersionsCallCount() int {
	fake.finishSavingVersionsMutex.RLock()
	defer fake.finishSavingVersionsMutex.RUnlock()
	return len(fake.finishSavingVersionsArgsForCall)
}

func (fake *FakeResourceConfigScope) FinishSavingVersionsCalls(stub func() error) {
	fake.finishSavingVersionsMutex.Lock()
	defer fake.finishSavingVersionsMutex.Unlock()
	fake.FinishSavingVersionsStub = stub
}

func (fake *FakeResourceConfigScope) FinishSavingVersionsReturns(result1 error) {
	fake.finishSavingVersionsMutex.Lock()
	defer fake.finishSavingVersionsMutex.Unlock()
	fake.FinishSavingVersionsStub = nil
	fake.finishSavingVersionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfigScope) FinishSavingVersionsReturnsOnCall(i int, result1 error) {
	fake.finishSavingVersionsMutex.Lock()
	defer fake.finishSavingVersionsMutex.Unlock()
	fake.FinishSavingVersionsStub = nil
	if fake.finishSavingVersionsReturnsOnCall == nil {
		fake.finishSavingVersionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.finishSavingVersionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfigScope) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.iDReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfigScope) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeResourceConfigScope) IDCalls(stub func() int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeResourceConfigScope) IDReturns(result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeResourceConfigScope) IDReturnsOnCall(i int, result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeResourceConfigScope) LatestVersions() ([]db.ResourceVersion, error) {
	fake.latestVersionsMutex.Lock()
	ret, specificReturn := fake.latestVersionsReturnsOnCall[len(fake.latestVersionsArgsForCall)]
	fake.latestVersionsArgsForCall = append(fake.latestVersionsArgsForCall, struct {
	}{})
	fake.recordInvocation("LatestVersions", []interface{}{})
	fake.latestVersionsMutex.Unlock()
	if fake.LatestVersionsStub != nil {
		return fake.LatestVersionsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.latestVersionsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceConfigScope) LatestVersionsCallCount() int {
	fake.latestVersionsMutex.RLock()
	defer fake.latestVersionsMutex.RUnlock()
	return len(fake.latestVersionsArgsForCall)
}

func (fake *FakeResourceConfigScope) LatestVersionsCalls(stub func() ([]db.ResourceVersion, error)) {
	fake.latestVersionsMutex.Lock()
	defer fake.latestVersionsMutex.Unlock()
	fake.LatestVersionsStub = stub
}

func (fake *FakeResourceConfigScope) LatestVersionsReturns(result1 []db.ResourceVersion, result2 error) {
	fake.latestVersionsMutex.Lock()
	defer fake.latestVersionsMutex.Unlock()
	fake.LatestVersionsStub = nil
	fake.latestVersionsReturns = struct {
		result1 []db.ResourceVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceConfigScope) LatestVersionsReturnsOnCall(i int, result1 []db.ResourceVersion, result2 error) {
	fake.latestVersionsMutex.Lock()
	defer fake.latestVersionsMutex.Unlock()
	fake.LatestVersionsStub = nil
	if fake.latestVersionsReturnsOnCall == nil {
		fake.latestVersionsReturnsOnCall = make(map[int]struct {
			result1 []db.ResourceVersion
			result2 error
		})
	}
	fake.latestVersionsReturnsOnCall[i] = struct {
		result1 []db.ResourceVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceConfigScope) Resource() db.Resource {
	fake.resourceMutex.Lock()
	ret, specificReturn := fake.resourceReturnsOnCall[len(fake.resourceArgsForCall)]
	fake.resourceArgsForCall = append(fake.resourceArgsForCall, struct {
	}{})
	fake.recordInvocation("Resource", []interface{}{})
	fake.resourceMutex.Unlock()
	if fake.ResourceStub != nil {
		return fake.ResourceStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.resourceReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfigScope) ResourceCallCount() int {
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	return len(fake.resourceArgsForCall)
}

func (fake *FakeResourceConfigScope) ResourceCalls(stub func() db.Resource) {
	fake.resourceMutex.Lock()
	defer fake.resourceMutex.Unlock()
	fake.ResourceStub = stub
}

func (fake *FakeResourceConfigScope) ResourceReturns(result1 db.Resource) {
	fake.resourceMutex.Lock()
	defer fake.resourceMutex.Unlock()
	fake.ResourceStub = nil
	fake.resourceReturns = struct {
		result1 db.Resource
	}{result1}
}

func (fake *FakeResourceConfigScope) ResourceReturnsOnCall(i int, result1 db.Resource) {
	fake.resourceMutex.Lock()
	defer fake.resourceMutex.Unlock()
	fake.ResourceStub = nil
	if fake.resourceReturnsOnCall == nil {
		fake.resourceReturnsOnCall = make(map[int]struct {
			result1 db.Resource
		})
	}
	fake.resourceReturnsOnCall[i] = struct {
		result1 db.Resource
	}{result1}
}

func (fake *FakeResourceConfigScope) ResourceConfig() db.ResourceConfig {
	fake.resourceConfigMutex.Lock()
	ret, specificReturn := fake.resourceConfigReturnsOnCall[len(fake.resourceConfigArgsForCall)]
	fake.resourceConfigArgsForCall = append(fake.resourceConfigArgsForCall, struct {
	}{})
	fake.recordInvocation("ResourceConfig", []interface{}{})
	fake.resourceConfigMutex.Unlock()
	if fake.ResourceConfigStub != nil {
		return fake.ResourceConfigStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.resourceConfigReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfigScope) ResourceConfigCallCount() int {
	fake.resourceConfigMutex.RLock()
	defer fake.resourceConfigMutex.RUnlock()
	return len(fake.resourceConfigArgsForCall)
}

func (fake *FakeResourceConfigScope) ResourceConfigCalls(stub func() db.ResourceConfig) {
	fake.resourceConfigMutex.Lock()
	defer fake.resourceConfigMutex.Unlock()
	fake.ResourceConfigStub = stub
}

func (fake *FakeResourceConfigScope) ResourceConfigReturns(result1 db.ResourceConfig) {
	fake.resourceConfigMutex.Lock()
	defer fake.resourceConfigMutex.Unlock()
	fake.ResourceConfigStub = nil
	fake.resourceConfigReturns = struct {
		result1 db.ResourceConfig
	}{result1}
}

func (fake *FakeResourceConfigScope) ResourceConfigReturnsOnCall(i int, result1 db.ResourceConfig) {
	fake.resourceConfigMutex.Lock()
	defer fake.resourceConfigMutex.Unlock()
	fake.ResourceConfigStub = nil
	if fake.resourceConfigReturnsOnCall == nil {
		fake.resourceConfigReturnsOnCall = make(map[int]struct {
			result1 db.ResourceConfig
		})
	}
	fake.resourceConfigReturnsOnCall[i] = struct {
		result1 db.ResourceConfig
	}{result1}
}

func (fake *FakeResourceConfigScope) SaveDefaultSpace(arg1 atc.Space) error {
	fake.saveDefaultSpaceMutex.Lock()
	ret, specificReturn := fake.saveDefaultSpaceReturnsOnCall[len(fake.saveDefaultSpaceArgsForCall)]
	fake.saveDefaultSpaceArgsForCall = append(fake.saveDefaultSpaceArgsForCall, struct {
		arg1 atc.Space
	}{arg1})
	fake.recordInvocation("SaveDefaultSpace", []interface{}{arg1})
	fake.saveDefaultSpaceMutex.Unlock()
	if fake.SaveDefaultSpaceStub != nil {
		return fake.SaveDefaultSpaceStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveDefaultSpaceReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfigScope) SaveDefaultSpaceCallCount() int {
	fake.saveDefaultSpaceMutex.RLock()
	defer fake.saveDefaultSpaceMutex.RUnlock()
	return len(fake.saveDefaultSpaceArgsForCall)
}

func (fake *FakeResourceConfigScope) SaveDefaultSpaceCalls(stub func(atc.Space) error) {
	fake.saveDefaultSpaceMutex.Lock()
	defer fake.saveDefaultSpaceMutex.Unlock()
	fake.SaveDefaultSpaceStub = stub
}

func (fake *FakeResourceConfigScope) SaveDefaultSpaceArgsForCall(i int) atc.Space {
	fake.saveDefaultSpaceMutex.RLock()
	defer fake.saveDefaultSpaceMutex.RUnlock()
	argsForCall := fake.saveDefaultSpaceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceConfigScope) SaveDefaultSpaceReturns(result1 error) {
	fake.saveDefaultSpaceMutex.Lock()
	defer fake.saveDefaultSpaceMutex.Unlock()
	fake.SaveDefaultSpaceStub = nil
	fake.saveDefaultSpaceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfigScope) SaveDefaultSpaceReturnsOnCall(i int, result1 error) {
	fake.saveDefaultSpaceMutex.Lock()
	defer fake.saveDefaultSpaceMutex.Unlock()
	fake.SaveDefaultSpaceStub = nil
	if fake.saveDefaultSpaceReturnsOnCall == nil {
		fake.saveDefaultSpaceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveDefaultSpaceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfigScope) SavePartialVersion(arg1 atc.Space, arg2 atc.Version, arg3 atc.Metadata) error {
	fake.savePartialVersionMutex.Lock()
	ret, specificReturn := fake.savePartialVersionReturnsOnCall[len(fake.savePartialVersionArgsForCall)]
	fake.savePartialVersionArgsForCall = append(fake.savePartialVersionArgsForCall, struct {
		arg1 atc.Space
		arg2 atc.Version
		arg3 atc.Metadata
	}{arg1, arg2, arg3})
	fake.recordInvocation("SavePartialVersion", []interface{}{arg1, arg2, arg3})
	fake.savePartialVersionMutex.Unlock()
	if fake.SavePartialVersionStub != nil {
		return fake.SavePartialVersionStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.savePartialVersionReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfigScope) SavePartialVersionCallCount() int {
	fake.savePartialVersionMutex.RLock()
	defer fake.savePartialVersionMutex.RUnlock()
	return len(fake.savePartialVersionArgsForCall)
}

func (fake *FakeResourceConfigScope) SavePartialVersionCalls(stub func(atc.Space, atc.Version, atc.Metadata) error) {
	fake.savePartialVersionMutex.Lock()
	defer fake.savePartialVersionMutex.Unlock()
	fake.SavePartialVersionStub = stub
}

func (fake *FakeResourceConfigScope) SavePartialVersionArgsForCall(i int) (atc.Space, atc.Version, atc.Metadata) {
	fake.savePartialVersionMutex.RLock()
	defer fake.savePartialVersionMutex.RUnlock()
	argsForCall := fake.savePartialVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeResourceConfigScope) SavePartialVersionReturns(result1 error) {
	fake.savePartialVersionMutex.Lock()
	defer fake.savePartialVersionMutex.Unlock()
	fake.SavePartialVersionStub = nil
	fake.savePartialVersionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfigScope) SavePartialVersionReturnsOnCall(i int, result1 error) {
	fake.savePartialVersionMutex.Lock()
	defer fake.savePartialVersionMutex.Unlock()
	fake.SavePartialVersionStub = nil
	if fake.savePartialVersionReturnsOnCall == nil {
		fake.savePartialVersionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.savePartialVersionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfigScope) SaveSpace(arg1 atc.Space) error {
	fake.saveSpaceMutex.Lock()
	ret, specificReturn := fake.saveSpaceReturnsOnCall[len(fake.saveSpaceArgsForCall)]
	fake.saveSpaceArgsForCall = append(fake.saveSpaceArgsForCall, struct {
		arg1 atc.Space
	}{arg1})
	fake.recordInvocation("SaveSpace", []interface{}{arg1})
	fake.saveSpaceMutex.Unlock()
	if fake.SaveSpaceStub != nil {
		return fake.SaveSpaceStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveSpaceReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfigScope) SaveSpaceCallCount() int {
	fake.saveSpaceMutex.RLock()
	defer fake.saveSpaceMutex.RUnlock()
	return len(fake.saveSpaceArgsForCall)
}

func (fake *FakeResourceConfigScope) SaveSpaceCalls(stub func(atc.Space) error) {
	fake.saveSpaceMutex.Lock()
	defer fake.saveSpaceMutex.Unlock()
	fake.SaveSpaceStub = stub
}

func (fake *FakeResourceConfigScope) SaveSpaceArgsForCall(i int) atc.Space {
	fake.saveSpaceMutex.RLock()
	defer fake.saveSpaceMutex.RUnlock()
	argsForCall := fake.saveSpaceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceConfigScope) SaveSpaceReturns(result1 error) {
	fake.saveSpaceMutex.Lock()
	defer fake.saveSpaceMutex.Unlock()
	fake.SaveSpaceStub = nil
	fake.saveSpaceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfigScope) SaveSpaceReturnsOnCall(i int, result1 error) {
	fake.saveSpaceMutex.Lock()
	defer fake.saveSpaceMutex.Unlock()
	fake.SaveSpaceStub = nil
	if fake.saveSpaceReturnsOnCall == nil {
		fake.saveSpaceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveSpaceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfigScope) SaveSpaceLatestVersion(arg1 atc.Space, arg2 atc.Version) error {
	fake.saveSpaceLatestVersionMutex.Lock()
	ret, specificReturn := fake.saveSpaceLatestVersionReturnsOnCall[len(fake.saveSpaceLatestVersionArgsForCall)]
	fake.saveSpaceLatestVersionArgsForCall = append(fake.saveSpaceLatestVersionArgsForCall, struct {
		arg1 atc.Space
		arg2 atc.Version
	}{arg1, arg2})
	fake.recordInvocation("SaveSpaceLatestVersion", []interface{}{arg1, arg2})
	fake.saveSpaceLatestVersionMutex.Unlock()
	if fake.SaveSpaceLatestVersionStub != nil {
		return fake.SaveSpaceLatestVersionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveSpaceLatestVersionReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfigScope) SaveSpaceLatestVersionCallCount() int {
	fake.saveSpaceLatestVersionMutex.RLock()
	defer fake.saveSpaceLatestVersionMutex.RUnlock()
	return len(fake.saveSpaceLatestVersionArgsForCall)
}

func (fake *FakeResourceConfigScope) SaveSpaceLatestVersionCalls(stub func(atc.Space, atc.Version) error) {
	fake.saveSpaceLatestVersionMutex.Lock()
	defer fake.saveSpaceLatestVersionMutex.Unlock()
	fake.SaveSpaceLatestVersionStub = stub
}

func (fake *FakeResourceConfigScope) SaveSpaceLatestVersionArgsForCall(i int) (atc.Space, atc.Version) {
	fake.saveSpaceLatestVersionMutex.RLock()
	defer fake.saveSpaceLatestVersionMutex.RUnlock()
	argsForCall := fake.saveSpaceLatestVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceConfigScope) SaveSpaceLatestVersionReturns(result1 error) {
	fake.saveSpaceLatestVersionMutex.Lock()
	defer fake.saveSpaceLatestVersionMutex.Unlock()
	fake.SaveSpaceLatestVersionStub = nil
	fake.saveSpaceLatestVersionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfigScope) SaveSpaceLatestVersionReturnsOnCall(i int, result1 error) {
	fake.saveSpaceLatestVersionMutex.Lock()
	defer fake.saveSpaceLatestVersionMutex.Unlock()
	fake.SaveSpaceLatestVersionStub = nil
	if fake.saveSpaceLatestVersionReturnsOnCall == nil {
		fake.saveSpaceLatestVersionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveSpaceLatestVersionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfigScope) SaveUncheckedVersion(arg1 atc.Space, arg2 atc.Version, arg3 db.ResourceConfigMetadataFields) (bool, error) {
	fake.saveUncheckedVersionMutex.Lock()
	ret, specificReturn := fake.saveUncheckedVersionReturnsOnCall[len(fake.saveUncheckedVersionArgsForCall)]
	fake.saveUncheckedVersionArgsForCall = append(fake.saveUncheckedVersionArgsForCall, struct {
		arg1 atc.Space
		arg2 atc.Version
		arg3 db.ResourceConfigMetadataFields
	}{arg1, arg2, arg3})
	fake.recordInvocation("SaveUncheckedVersion", []interface{}{arg1, arg2, arg3})
	fake.saveUncheckedVersionMutex.Unlock()
	if fake.SaveUncheckedVersionStub != nil {
		return fake.SaveUncheckedVersionStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.saveUncheckedVersionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceConfigScope) SaveUncheckedVersionCallCount() int {
	fake.saveUncheckedVersionMutex.RLock()
	defer fake.saveUncheckedVersionMutex.RUnlock()
	return len(fake.saveUncheckedVersionArgsForCall)
}

func (fake *FakeResourceConfigScope) SaveUncheckedVersionCalls(stub func(atc.Space, atc.Version, db.ResourceConfigMetadataFields) (bool, error)) {
	fake.saveUncheckedVersionMutex.Lock()
	defer fake.saveUncheckedVersionMutex.Unlock()
	fake.SaveUncheckedVersionStub = stub
}

func (fake *FakeResourceConfigScope) SaveUncheckedVersionArgsForCall(i int) (atc.Space, atc.Version, db.ResourceConfigMetadataFields) {
	fake.saveUncheckedVersionMutex.RLock()
	defer fake.saveUncheckedVersionMutex.RUnlock()
	argsForCall := fake.saveUncheckedVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeResourceConfigScope) SaveUncheckedVersionReturns(result1 bool, result2 error) {
	fake.saveUncheckedVersionMutex.Lock()
	defer fake.saveUncheckedVersionMutex.Unlock()
	fake.SaveUncheckedVersionStub = nil
	fake.saveUncheckedVersionReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceConfigScope) SaveUncheckedVersionReturnsOnCall(i int, result1 bool, result2 error) {
	fake.saveUncheckedVersionMutex.Lock()
	defer fake.saveUncheckedVersionMutex.Unlock()
	fake.SaveUncheckedVersionStub = nil
	if fake.saveUncheckedVersionReturnsOnCall == nil {
		fake.saveUncheckedVersionReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.saveUncheckedVersionReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceConfigScope) SetCheckError(arg1 error) error {
	fake.setCheckErrorMutex.Lock()
	ret, specificReturn := fake.setCheckErrorReturnsOnCall[len(fake.setCheckErrorArgsForCall)]
	fake.setCheckErrorArgsForCall = append(fake.setCheckErrorArgsForCall, struct {
		arg1 error
	}{arg1})
	fake.recordInvocation("SetCheckError", []interface{}{arg1})
	fake.setCheckErrorMutex.Unlock()
	if fake.SetCheckErrorStub != nil {
		return fake.SetCheckErrorStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setCheckErrorReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfigScope) SetCheckErrorCallCount() int {
	fake.setCheckErrorMutex.RLock()
	defer fake.setCheckErrorMutex.RUnlock()
	return len(fake.setCheckErrorArgsForCall)
}

func (fake *FakeResourceConfigScope) SetCheckErrorCalls(stub func(error) error) {
	fake.setCheckErrorMutex.Lock()
	defer fake.setCheckErrorMutex.Unlock()
	fake.SetCheckErrorStub = stub
}

func (fake *FakeResourceConfigScope) SetCheckErrorArgsForCall(i int) error {
	fake.setCheckErrorMutex.RLock()
	defer fake.setCheckErrorMutex.RUnlock()
	argsForCall := fake.setCheckErrorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceConfigScope) SetCheckErrorReturns(result1 error) {
	fake.setCheckErrorMutex.Lock()
	defer fake.setCheckErrorMutex.Unlock()
	fake.SetCheckErrorStub = nil
	fake.setCheckErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfigScope) SetCheckErrorReturnsOnCall(i int, result1 error) {
	fake.setCheckErrorMutex.Lock()
	defer fake.setCheckErrorMutex.Unlock()
	fake.SetCheckErrorStub = nil
	if fake.setCheckErrorReturnsOnCall == nil {
		fake.setCheckErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setCheckErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfigScope) UpdateLastCheckFinished() (bool, error) {
	fake.updateLastCheckFinishedMutex.Lock()
	ret, specificReturn := fake.updateLastCheckFinishedReturnsOnCall[len(fake.updateLastCheckFinishedArgsForCall)]
	fake.updateLastCheckFinishedArgsForCall = append(fake.updateLastCheckFinishedArgsForCall, struct {
	}{})
	fake.recordInvocation("UpdateLastCheckFinished", []interface{}{})
	fake.updateLastCheckFinishedMutex.Unlock()
	if fake.UpdateLastCheckFinishedStub != nil {
		return fake.UpdateLastCheckFinishedStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateLastCheckFinishedReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceConfigScope) UpdateLastCheckFinishedCallCount() int {
	fake.updateLastCheckFinishedMutex.RLock()
	defer fake.updateLastCheckFinishedMutex.RUnlock()
	return len(fake.updateLastCheckFinishedArgsForCall)
}

func (fake *FakeResourceConfigScope) UpdateLastCheckFinishedCalls(stub func() (bool, error)) {
	fake.updateLastCheckFinishedMutex.Lock()
	defer fake.updateLastCheckFinishedMutex.Unlock()
	fake.UpdateLastCheckFinishedStub = stub
}

func (fake *FakeResourceConfigScope) UpdateLastCheckFinishedReturns(result1 bool, result2 error) {
	fake.updateLastCheckFinishedMutex.Lock()
	defer fake.updateLastCheckFinishedMutex.Unlock()
	fake.UpdateLastCheckFinishedStub = nil
	fake.updateLastCheckFinishedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceConfigScope) UpdateLastCheckFinishedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.updateLastCheckFinishedMutex.Lock()
	defer fake.updateLastCheckFinishedMutex.Unlock()
	fake.UpdateLastCheckFinishedStub = nil
	if fake.updateLastCheckFinishedReturnsOnCall == nil {
		fake.updateLastCheckFinishedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.updateLastCheckFinishedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceConfigScope) UpdateLastChecked(arg1 time.Duration, arg2 bool) (bool, error) {
	fake.updateLastCheckedMutex.Lock()
	ret, specificReturn := fake.updateLastCheckedReturnsOnCall[len(fake.updateLastCheckedArgsForCall)]
	fake.updateLastCheckedArgsForCall = append(fake.updateLastCheckedArgsForCall, struct {
		arg1 time.Duration
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("UpdateLastChecked", []interface{}{arg1, arg2})
	fake.updateLastCheckedMutex.Unlock()
	if fake.UpdateLastCheckedStub != nil {
		return fake.UpdateLastCheckedStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateLastCheckedReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceConfigScope) UpdateLastCheckedCallCount() int {
	fake.updateLastCheckedMutex.RLock()
	defer fake.updateLastCheckedMutex.RUnlock()
	return len(fake.updateLastCheckedArgsForCall)
}

func (fake *FakeResourceConfigScope) UpdateLastCheckedCalls(stub func(time.Duration, bool) (bool, error)) {
	fake.updateLastCheckedMutex.Lock()
	defer fake.updateLastCheckedMutex.Unlock()
	fake.UpdateLastCheckedStub = stub
}

func (fake *FakeResourceConfigScope) UpdateLastCheckedArgsForCall(i int) (time.Duration, bool) {
	fake.updateLastCheckedMutex.RLock()
	defer fake.updateLastCheckedMutex.RUnlock()
	argsForCall := fake.updateLastCheckedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceConfigScope) UpdateLastCheckedReturns(result1 bool, result2 error) {
	fake.updateLastCheckedMutex.Lock()
	defer fake.updateLastCheckedMutex.Unlock()
	fake.UpdateLastCheckedStub = nil
	fake.updateLastCheckedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceConfigScope) UpdateLastCheckedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.updateLastCheckedMutex.Lock()
	defer fake.updateLastCheckedMutex.Unlock()
	fake.UpdateLastCheckedStub = nil
	if fake.updateLastCheckedReturnsOnCall == nil {
		fake.updateLastCheckedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.updateLastCheckedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceConfigScope) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.acquireResourceCheckingLockMutex.RLock()
	defer fake.acquireResourceCheckingLockMutex.RUnlock()
	fake.checkErrorMutex.RLock()
	defer fake.checkErrorMutex.RUnlock()
	fake.defaultSpaceMutex.RLock()
	defer fake.defaultSpaceMutex.RUnlock()
	fake.findUncheckedVersionMutex.RLock()
	defer fake.findUncheckedVersionMutex.RUnlock()
	fake.findVersionMutex.RLock()
	defer fake.findVersionMutex.RUnlock()
	fake.finishSavingVersionsMutex.RLock()
	defer fake.finishSavingVersionsMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.latestVersionsMutex.RLock()
	defer fake.latestVersionsMutex.RUnlock()
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	fake.resourceConfigMutex.RLock()
	defer fake.resourceConfigMutex.RUnlock()
	fake.saveDefaultSpaceMutex.RLock()
	defer fake.saveDefaultSpaceMutex.RUnlock()
	fake.savePartialVersionMutex.RLock()
	defer fake.savePartialVersionMutex.RUnlock()
	fake.saveSpaceMutex.RLock()
	defer fake.saveSpaceMutex.RUnlock()
	fake.saveSpaceLatestVersionMutex.RLock()
	defer fake.saveSpaceLatestVersionMutex.RUnlock()
	fake.saveUncheckedVersionMutex.RLock()
	defer fake.saveUncheckedVersionMutex.RUnlock()
	fake.setCheckErrorMutex.RLock()
	defer fake.setCheckErrorMutex.RUnlock()
	fake.updateLastCheckFinishedMutex.RLock()
	defer fake.updateLastCheckFinishedMutex.RUnlock()
	fake.updateLastCheckedMutex.RLock()
	defer fake.updateLastCheckedMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeResourceConfigScope) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.ResourceConfigScope = new(FakeResourceConfigScope)
