// Code generated by counterfeiter. DO NOT EDIT.
package gcontainerdfakes

import (
	"context"
	"io"
	"sync"

	"github.com/concourse/concourse/gcontainerd"
	"github.com/containerd/containerd"
	"github.com/containerd/containerd/images"
	"github.com/containerd/containerd/snapshots"
)

type FakeClient struct {
	ContainersStub        func(context.Context, ...string) ([]containerd.Container, error)
	containersMutex       sync.RWMutex
	containersArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	containersReturns struct {
		result1 []containerd.Container
		result2 error
	}
	containersReturnsOnCall map[int]struct {
		result1 []containerd.Container
		result2 error
	}
	GetImageStub        func(context.Context, string) (containerd.Image, error)
	getImageMutex       sync.RWMutex
	getImageArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getImageReturns struct {
		result1 containerd.Image
		result2 error
	}
	getImageReturnsOnCall map[int]struct {
		result1 containerd.Image
		result2 error
	}
	ImageServiceStub        func() images.Store
	imageServiceMutex       sync.RWMutex
	imageServiceArgsForCall []struct {
	}
	imageServiceReturns struct {
		result1 images.Store
	}
	imageServiceReturnsOnCall map[int]struct {
		result1 images.Store
	}
	ImportStub        func(context.Context, io.Reader, ...containerd.ImportOpt) ([]images.Image, error)
	importMutex       sync.RWMutex
	importArgsForCall []struct {
		arg1 context.Context
		arg2 io.Reader
		arg3 []containerd.ImportOpt
	}
	importReturns struct {
		result1 []images.Image
		result2 error
	}
	importReturnsOnCall map[int]struct {
		result1 []images.Image
		result2 error
	}
	LoadContainerStub        func(context.Context, string) (containerd.Container, error)
	loadContainerMutex       sync.RWMutex
	loadContainerArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	loadContainerReturns struct {
		result1 containerd.Container
		result2 error
	}
	loadContainerReturnsOnCall map[int]struct {
		result1 containerd.Container
		result2 error
	}
	NewContainerStub        func(context.Context, string, ...containerd.NewContainerOpts) (containerd.Container, error)
	newContainerMutex       sync.RWMutex
	newContainerArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []containerd.NewContainerOpts
	}
	newContainerReturns struct {
		result1 containerd.Container
		result2 error
	}
	newContainerReturnsOnCall map[int]struct {
		result1 containerd.Container
		result2 error
	}
	PullStub        func(context.Context, string, ...containerd.RemoteOpt) (containerd.Image, error)
	pullMutex       sync.RWMutex
	pullArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []containerd.RemoteOpt
	}
	pullReturns struct {
		result1 containerd.Image
		result2 error
	}
	pullReturnsOnCall map[int]struct {
		result1 containerd.Image
		result2 error
	}
	SnapshotServiceStub        func(string) snapshots.Snapshotter
	snapshotServiceMutex       sync.RWMutex
	snapshotServiceArgsForCall []struct {
		arg1 string
	}
	snapshotServiceReturns struct {
		result1 snapshots.Snapshotter
	}
	snapshotServiceReturnsOnCall map[int]struct {
		result1 snapshots.Snapshotter
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) Containers(arg1 context.Context, arg2 ...string) ([]containerd.Container, error) {
	fake.containersMutex.Lock()
	ret, specificReturn := fake.containersReturnsOnCall[len(fake.containersArgsForCall)]
	fake.containersArgsForCall = append(fake.containersArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	fake.recordInvocation("Containers", []interface{}{arg1, arg2})
	fake.containersMutex.Unlock()
	if fake.ContainersStub != nil {
		return fake.ContainersStub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ContainersCallCount() int {
	fake.containersMutex.RLock()
	defer fake.containersMutex.RUnlock()
	return len(fake.containersArgsForCall)
}

func (fake *FakeClient) ContainersCalls(stub func(context.Context, ...string) ([]containerd.Container, error)) {
	fake.containersMutex.Lock()
	defer fake.containersMutex.Unlock()
	fake.ContainersStub = stub
}

func (fake *FakeClient) ContainersArgsForCall(i int) (context.Context, []string) {
	fake.containersMutex.RLock()
	defer fake.containersMutex.RUnlock()
	argsForCall := fake.containersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ContainersReturns(result1 []containerd.Container, result2 error) {
	fake.containersMutex.Lock()
	defer fake.containersMutex.Unlock()
	fake.ContainersStub = nil
	fake.containersReturns = struct {
		result1 []containerd.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ContainersReturnsOnCall(i int, result1 []containerd.Container, result2 error) {
	fake.containersMutex.Lock()
	defer fake.containersMutex.Unlock()
	fake.ContainersStub = nil
	if fake.containersReturnsOnCall == nil {
		fake.containersReturnsOnCall = make(map[int]struct {
			result1 []containerd.Container
			result2 error
		})
	}
	fake.containersReturnsOnCall[i] = struct {
		result1 []containerd.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetImage(arg1 context.Context, arg2 string) (containerd.Image, error) {
	fake.getImageMutex.Lock()
	ret, specificReturn := fake.getImageReturnsOnCall[len(fake.getImageArgsForCall)]
	fake.getImageArgsForCall = append(fake.getImageArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetImage", []interface{}{arg1, arg2})
	fake.getImageMutex.Unlock()
	if fake.GetImageStub != nil {
		return fake.GetImageStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getImageReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetImageCallCount() int {
	fake.getImageMutex.RLock()
	defer fake.getImageMutex.RUnlock()
	return len(fake.getImageArgsForCall)
}

func (fake *FakeClient) GetImageCalls(stub func(context.Context, string) (containerd.Image, error)) {
	fake.getImageMutex.Lock()
	defer fake.getImageMutex.Unlock()
	fake.GetImageStub = stub
}

func (fake *FakeClient) GetImageArgsForCall(i int) (context.Context, string) {
	fake.getImageMutex.RLock()
	defer fake.getImageMutex.RUnlock()
	argsForCall := fake.getImageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetImageReturns(result1 containerd.Image, result2 error) {
	fake.getImageMutex.Lock()
	defer fake.getImageMutex.Unlock()
	fake.GetImageStub = nil
	fake.getImageReturns = struct {
		result1 containerd.Image
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetImageReturnsOnCall(i int, result1 containerd.Image, result2 error) {
	fake.getImageMutex.Lock()
	defer fake.getImageMutex.Unlock()
	fake.GetImageStub = nil
	if fake.getImageReturnsOnCall == nil {
		fake.getImageReturnsOnCall = make(map[int]struct {
			result1 containerd.Image
			result2 error
		})
	}
	fake.getImageReturnsOnCall[i] = struct {
		result1 containerd.Image
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ImageService() images.Store {
	fake.imageServiceMutex.Lock()
	ret, specificReturn := fake.imageServiceReturnsOnCall[len(fake.imageServiceArgsForCall)]
	fake.imageServiceArgsForCall = append(fake.imageServiceArgsForCall, struct {
	}{})
	fake.recordInvocation("ImageService", []interface{}{})
	fake.imageServiceMutex.Unlock()
	if fake.ImageServiceStub != nil {
		return fake.ImageServiceStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.imageServiceReturns
	return fakeReturns.result1
}

func (fake *FakeClient) ImageServiceCallCount() int {
	fake.imageServiceMutex.RLock()
	defer fake.imageServiceMutex.RUnlock()
	return len(fake.imageServiceArgsForCall)
}

func (fake *FakeClient) ImageServiceCalls(stub func() images.Store) {
	fake.imageServiceMutex.Lock()
	defer fake.imageServiceMutex.Unlock()
	fake.ImageServiceStub = stub
}

func (fake *FakeClient) ImageServiceReturns(result1 images.Store) {
	fake.imageServiceMutex.Lock()
	defer fake.imageServiceMutex.Unlock()
	fake.ImageServiceStub = nil
	fake.imageServiceReturns = struct {
		result1 images.Store
	}{result1}
}

func (fake *FakeClient) ImageServiceReturnsOnCall(i int, result1 images.Store) {
	fake.imageServiceMutex.Lock()
	defer fake.imageServiceMutex.Unlock()
	fake.ImageServiceStub = nil
	if fake.imageServiceReturnsOnCall == nil {
		fake.imageServiceReturnsOnCall = make(map[int]struct {
			result1 images.Store
		})
	}
	fake.imageServiceReturnsOnCall[i] = struct {
		result1 images.Store
	}{result1}
}

func (fake *FakeClient) Import(arg1 context.Context, arg2 io.Reader, arg3 ...containerd.ImportOpt) ([]images.Image, error) {
	fake.importMutex.Lock()
	ret, specificReturn := fake.importReturnsOnCall[len(fake.importArgsForCall)]
	fake.importArgsForCall = append(fake.importArgsForCall, struct {
		arg1 context.Context
		arg2 io.Reader
		arg3 []containerd.ImportOpt
	}{arg1, arg2, arg3})
	fake.recordInvocation("Import", []interface{}{arg1, arg2, arg3})
	fake.importMutex.Unlock()
	if fake.ImportStub != nil {
		return fake.ImportStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.importReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ImportCallCount() int {
	fake.importMutex.RLock()
	defer fake.importMutex.RUnlock()
	return len(fake.importArgsForCall)
}

func (fake *FakeClient) ImportCalls(stub func(context.Context, io.Reader, ...containerd.ImportOpt) ([]images.Image, error)) {
	fake.importMutex.Lock()
	defer fake.importMutex.Unlock()
	fake.ImportStub = stub
}

func (fake *FakeClient) ImportArgsForCall(i int) (context.Context, io.Reader, []containerd.ImportOpt) {
	fake.importMutex.RLock()
	defer fake.importMutex.RUnlock()
	argsForCall := fake.importArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ImportReturns(result1 []images.Image, result2 error) {
	fake.importMutex.Lock()
	defer fake.importMutex.Unlock()
	fake.ImportStub = nil
	fake.importReturns = struct {
		result1 []images.Image
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ImportReturnsOnCall(i int, result1 []images.Image, result2 error) {
	fake.importMutex.Lock()
	defer fake.importMutex.Unlock()
	fake.ImportStub = nil
	if fake.importReturnsOnCall == nil {
		fake.importReturnsOnCall = make(map[int]struct {
			result1 []images.Image
			result2 error
		})
	}
	fake.importReturnsOnCall[i] = struct {
		result1 []images.Image
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) LoadContainer(arg1 context.Context, arg2 string) (containerd.Container, error) {
	fake.loadContainerMutex.Lock()
	ret, specificReturn := fake.loadContainerReturnsOnCall[len(fake.loadContainerArgsForCall)]
	fake.loadContainerArgsForCall = append(fake.loadContainerArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("LoadContainer", []interface{}{arg1, arg2})
	fake.loadContainerMutex.Unlock()
	if fake.LoadContainerStub != nil {
		return fake.LoadContainerStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.loadContainerReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) LoadContainerCallCount() int {
	fake.loadContainerMutex.RLock()
	defer fake.loadContainerMutex.RUnlock()
	return len(fake.loadContainerArgsForCall)
}

func (fake *FakeClient) LoadContainerCalls(stub func(context.Context, string) (containerd.Container, error)) {
	fake.loadContainerMutex.Lock()
	defer fake.loadContainerMutex.Unlock()
	fake.LoadContainerStub = stub
}

func (fake *FakeClient) LoadContainerArgsForCall(i int) (context.Context, string) {
	fake.loadContainerMutex.RLock()
	defer fake.loadContainerMutex.RUnlock()
	argsForCall := fake.loadContainerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) LoadContainerReturns(result1 containerd.Container, result2 error) {
	fake.loadContainerMutex.Lock()
	defer fake.loadContainerMutex.Unlock()
	fake.LoadContainerStub = nil
	fake.loadContainerReturns = struct {
		result1 containerd.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) LoadContainerReturnsOnCall(i int, result1 containerd.Container, result2 error) {
	fake.loadContainerMutex.Lock()
	defer fake.loadContainerMutex.Unlock()
	fake.LoadContainerStub = nil
	if fake.loadContainerReturnsOnCall == nil {
		fake.loadContainerReturnsOnCall = make(map[int]struct {
			result1 containerd.Container
			result2 error
		})
	}
	fake.loadContainerReturnsOnCall[i] = struct {
		result1 containerd.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) NewContainer(arg1 context.Context, arg2 string, arg3 ...containerd.NewContainerOpts) (containerd.Container, error) {
	fake.newContainerMutex.Lock()
	ret, specificReturn := fake.newContainerReturnsOnCall[len(fake.newContainerArgsForCall)]
	fake.newContainerArgsForCall = append(fake.newContainerArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []containerd.NewContainerOpts
	}{arg1, arg2, arg3})
	fake.recordInvocation("NewContainer", []interface{}{arg1, arg2, arg3})
	fake.newContainerMutex.Unlock()
	if fake.NewContainerStub != nil {
		return fake.NewContainerStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.newContainerReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) NewContainerCallCount() int {
	fake.newContainerMutex.RLock()
	defer fake.newContainerMutex.RUnlock()
	return len(fake.newContainerArgsForCall)
}

func (fake *FakeClient) NewContainerCalls(stub func(context.Context, string, ...containerd.NewContainerOpts) (containerd.Container, error)) {
	fake.newContainerMutex.Lock()
	defer fake.newContainerMutex.Unlock()
	fake.NewContainerStub = stub
}

func (fake *FakeClient) NewContainerArgsForCall(i int) (context.Context, string, []containerd.NewContainerOpts) {
	fake.newContainerMutex.RLock()
	defer fake.newContainerMutex.RUnlock()
	argsForCall := fake.newContainerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) NewContainerReturns(result1 containerd.Container, result2 error) {
	fake.newContainerMutex.Lock()
	defer fake.newContainerMutex.Unlock()
	fake.NewContainerStub = nil
	fake.newContainerReturns = struct {
		result1 containerd.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) NewContainerReturnsOnCall(i int, result1 containerd.Container, result2 error) {
	fake.newContainerMutex.Lock()
	defer fake.newContainerMutex.Unlock()
	fake.NewContainerStub = nil
	if fake.newContainerReturnsOnCall == nil {
		fake.newContainerReturnsOnCall = make(map[int]struct {
			result1 containerd.Container
			result2 error
		})
	}
	fake.newContainerReturnsOnCall[i] = struct {
		result1 containerd.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Pull(arg1 context.Context, arg2 string, arg3 ...containerd.RemoteOpt) (containerd.Image, error) {
	fake.pullMutex.Lock()
	ret, specificReturn := fake.pullReturnsOnCall[len(fake.pullArgsForCall)]
	fake.pullArgsForCall = append(fake.pullArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []containerd.RemoteOpt
	}{arg1, arg2, arg3})
	fake.recordInvocation("Pull", []interface{}{arg1, arg2, arg3})
	fake.pullMutex.Unlock()
	if fake.PullStub != nil {
		return fake.PullStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.pullReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PullCallCount() int {
	fake.pullMutex.RLock()
	defer fake.pullMutex.RUnlock()
	return len(fake.pullArgsForCall)
}

func (fake *FakeClient) PullCalls(stub func(context.Context, string, ...containerd.RemoteOpt) (containerd.Image, error)) {
	fake.pullMutex.Lock()
	defer fake.pullMutex.Unlock()
	fake.PullStub = stub
}

func (fake *FakeClient) PullArgsForCall(i int) (context.Context, string, []containerd.RemoteOpt) {
	fake.pullMutex.RLock()
	defer fake.pullMutex.RUnlock()
	argsForCall := fake.pullArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) PullReturns(result1 containerd.Image, result2 error) {
	fake.pullMutex.Lock()
	defer fake.pullMutex.Unlock()
	fake.PullStub = nil
	fake.pullReturns = struct {
		result1 containerd.Image
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PullReturnsOnCall(i int, result1 containerd.Image, result2 error) {
	fake.pullMutex.Lock()
	defer fake.pullMutex.Unlock()
	fake.PullStub = nil
	if fake.pullReturnsOnCall == nil {
		fake.pullReturnsOnCall = make(map[int]struct {
			result1 containerd.Image
			result2 error
		})
	}
	fake.pullReturnsOnCall[i] = struct {
		result1 containerd.Image
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SnapshotService(arg1 string) snapshots.Snapshotter {
	fake.snapshotServiceMutex.Lock()
	ret, specificReturn := fake.snapshotServiceReturnsOnCall[len(fake.snapshotServiceArgsForCall)]
	fake.snapshotServiceArgsForCall = append(fake.snapshotServiceArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SnapshotService", []interface{}{arg1})
	fake.snapshotServiceMutex.Unlock()
	if fake.SnapshotServiceStub != nil {
		return fake.SnapshotServiceStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.snapshotServiceReturns
	return fakeReturns.result1
}

func (fake *FakeClient) SnapshotServiceCallCount() int {
	fake.snapshotServiceMutex.RLock()
	defer fake.snapshotServiceMutex.RUnlock()
	return len(fake.snapshotServiceArgsForCall)
}

func (fake *FakeClient) SnapshotServiceCalls(stub func(string) snapshots.Snapshotter) {
	fake.snapshotServiceMutex.Lock()
	defer fake.snapshotServiceMutex.Unlock()
	fake.SnapshotServiceStub = stub
}

func (fake *FakeClient) SnapshotServiceArgsForCall(i int) string {
	fake.snapshotServiceMutex.RLock()
	defer fake.snapshotServiceMutex.RUnlock()
	argsForCall := fake.snapshotServiceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) SnapshotServiceReturns(result1 snapshots.Snapshotter) {
	fake.snapshotServiceMutex.Lock()
	defer fake.snapshotServiceMutex.Unlock()
	fake.SnapshotServiceStub = nil
	fake.snapshotServiceReturns = struct {
		result1 snapshots.Snapshotter
	}{result1}
}

func (fake *FakeClient) SnapshotServiceReturnsOnCall(i int, result1 snapshots.Snapshotter) {
	fake.snapshotServiceMutex.Lock()
	defer fake.snapshotServiceMutex.Unlock()
	fake.SnapshotServiceStub = nil
	if fake.snapshotServiceReturnsOnCall == nil {
		fake.snapshotServiceReturnsOnCall = make(map[int]struct {
			result1 snapshots.Snapshotter
		})
	}
	fake.snapshotServiceReturnsOnCall[i] = struct {
		result1 snapshots.Snapshotter
	}{result1}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.containersMutex.RLock()
	defer fake.containersMutex.RUnlock()
	fake.getImageMutex.RLock()
	defer fake.getImageMutex.RUnlock()
	fake.imageServiceMutex.RLock()
	defer fake.imageServiceMutex.RUnlock()
	fake.importMutex.RLock()
	defer fake.importMutex.RUnlock()
	fake.loadContainerMutex.RLock()
	defer fake.loadContainerMutex.RUnlock()
	fake.newContainerMutex.RLock()
	defer fake.newContainerMutex.RUnlock()
	fake.pullMutex.RLock()
	defer fake.pullMutex.RUnlock()
	fake.snapshotServiceMutex.RLock()
	defer fake.snapshotServiceMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ gcontainerd.Client = new(FakeClient)
