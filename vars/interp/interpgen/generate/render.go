package generate

import (
	"bytes"
	"go/format"
	"html/template"
	"regexp"
	"sort"
	"strings"
)

// TODO: simplify, only named types are allowed
var mapRegexp = regexp.MustCompile(`^map\[(.+)\](.+)$`)
var listRegexp = regexp.MustCompile(`^\[.*\](.+)$`)

var tmpl = template.Must(template.New("output").
	Funcs(template.FuncMap{
		"InterpName":   interpName,
		"ValueName":    valueName,
		"VariableName": variableName,
	}).
	Parse(`// Code generated by github.com/concourse/concourse/vars/interp/interpgen. Do not modify!

package {{ .Package }}

import (
	"encoding/json"

	"github.com/concourse/concourse/vars/interp"
)

{{ range .Types -}}
type {{ InterpName . }} struct {
	I interface {
		Interpolate(interp.Resolver) ({{ .Name }}, error)
	}
}
type {{ VariableName . }} interp.Var

func (v {{ ValueName . }}) Interpolate(interp.Resolver) ({{ .Name }}, error) {
	return {{ .Name }}(v), nil
}
func (v {{ ValueName . }}) Wrap() {{ InterpName . }} { return {{ InterpName . }}{I: v} }
func (v {{ ValueName . }}) WrapPtr() *{{ InterpName . }} { return &{{ InterpName . }}{I: v} }
func (v {{ VariableName . }}) Interpolate(r interp.Resolver) ({{ .Name }}, error) {
	var dst {{ .Name }}
	err := interp.Var(v).InterpolateInto(r, &dst)
	return dst, err
}

func (i {{ InterpName . }}) MarshalJSON() ([]byte, error) { return json.Marshal(i.I) }
func (i *{{ InterpName . }}) UnmarshalJSON(data []byte) error {
	var v interp.Var
	if err := json.Unmarshal(data, &v); err == nil {
		i.I = {{ VariableName . }}(v)
		return nil
	}
	var raw {{ .Name }}
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	i.I = {{ ValueName . }}(raw)
	return nil
}
{{ end }}
`))

func Render(pkgName string, tis []TypeInfo) ([]byte, error) {
	sort.Slice(tis, func(i, j int) bool {
		if tis[i].Export != tis[j].Export {
			return tis[i].Export
		}
		return strings.Compare(canonicalName(tis[i].Name), canonicalName(tis[j].Name)) < 0
	})
	buf := new(bytes.Buffer)
	err := tmpl.Execute(buf, struct {
		Package string
		Types   []TypeInfo
	}{
		Package: pkgName,
		Types:   tis,
	})
	if err != nil {
		return nil, err
	}
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, err
	}
	return formatted, nil
}

func interpName(t TypeInfo) string {
	name := "interp" + canonicalName(t.Name)
	if t.Export {
		name = capitalize(name)
	}
	return name
}

func valueName(t TypeInfo) string {
	return t.Name
}

func variableName(t TypeInfo) string {
	return "interp" + canonicalName(t.Name) + "Var"
}

func canonicalName(name string) string {
	if sub := mapRegexp.FindStringSubmatch(name); len(sub) > 0 {
		return "Map" + canonicalName(sub[1]) + canonicalName(sub[2])
	}
	if sub := listRegexp.FindStringSubmatch(name); len(sub) > 0 {
		return "List" + canonicalName(sub[1])
	}
	name = capitalize(name)
	name = strings.ReplaceAll(name, "{}", "")
	return name
}

func capitalize(s string) string {
	return strings.ToUpper(s[:1]) + s[1:]
}
